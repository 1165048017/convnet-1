// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: convnet_config.proto

#ifndef PROTOBUF_convnet_5fconfig_2eproto__INCLUDED
#define PROTOBUF_convnet_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace config {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_convnet_5fconfig_2eproto();
void protobuf_AssignDesc_convnet_5fconfig_2eproto();
void protobuf_ShutdownFile_convnet_5fconfig_2eproto();

class Layer;
class Optimizer;
class Edge;
class Model;
class DatasetConfig;

enum Layer_Activation {
  Layer_Activation_LINEAR = 0,
  Layer_Activation_LOGISTIC = 1,
  Layer_Activation_RECTIFIED_LINEAR = 2,
  Layer_Activation_SOFTMAX = 3,
  Layer_Activation_SOFTMAX_DIST = 4
};
bool Layer_Activation_IsValid(int value);
const Layer_Activation Layer_Activation_Activation_MIN = Layer_Activation_LINEAR;
const Layer_Activation Layer_Activation_Activation_MAX = Layer_Activation_SOFTMAX_DIST;
const int Layer_Activation_Activation_ARRAYSIZE = Layer_Activation_Activation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Layer_Activation_descriptor();
inline const ::std::string& Layer_Activation_Name(Layer_Activation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Layer_Activation_descriptor(), value);
}
inline bool Layer_Activation_Parse(
    const ::std::string& name, Layer_Activation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Layer_Activation>(
    Layer_Activation_descriptor(), name, value);
}
enum Optimizer_OptimizerType {
  Optimizer_OptimizerType_STOCHASTIC_GRADIENT_DESCENT = 0,
  Optimizer_OptimizerType_LBFGS = 1
};
bool Optimizer_OptimizerType_IsValid(int value);
const Optimizer_OptimizerType Optimizer_OptimizerType_OptimizerType_MIN = Optimizer_OptimizerType_STOCHASTIC_GRADIENT_DESCENT;
const Optimizer_OptimizerType Optimizer_OptimizerType_OptimizerType_MAX = Optimizer_OptimizerType_LBFGS;
const int Optimizer_OptimizerType_OptimizerType_ARRAYSIZE = Optimizer_OptimizerType_OptimizerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Optimizer_OptimizerType_descriptor();
inline const ::std::string& Optimizer_OptimizerType_Name(Optimizer_OptimizerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Optimizer_OptimizerType_descriptor(), value);
}
inline bool Optimizer_OptimizerType_Parse(
    const ::std::string& name, Optimizer_OptimizerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Optimizer_OptimizerType>(
    Optimizer_OptimizerType_descriptor(), name, value);
}
enum Optimizer_Decay {
  Optimizer_Decay_NONE = 0,
  Optimizer_Decay_INVERSE_T = 1,
  Optimizer_Decay_EXPONENTIAL = 2,
  Optimizer_Decay_LINEAR = 3
};
bool Optimizer_Decay_IsValid(int value);
const Optimizer_Decay Optimizer_Decay_Decay_MIN = Optimizer_Decay_NONE;
const Optimizer_Decay Optimizer_Decay_Decay_MAX = Optimizer_Decay_LINEAR;
const int Optimizer_Decay_Decay_ARRAYSIZE = Optimizer_Decay_Decay_MAX + 1;

const ::google::protobuf::EnumDescriptor* Optimizer_Decay_descriptor();
inline const ::std::string& Optimizer_Decay_Name(Optimizer_Decay value) {
  return ::google::protobuf::internal::NameOfEnum(
    Optimizer_Decay_descriptor(), value);
}
inline bool Optimizer_Decay_Parse(
    const ::std::string& name, Optimizer_Decay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Optimizer_Decay>(
    Optimizer_Decay_descriptor(), name, value);
}
enum Edge_EdgeType {
  Edge_EdgeType_FC = 0,
  Edge_EdgeType_CONVOLUTIONAL = 1,
  Edge_EdgeType_LOCAL = 2,
  Edge_EdgeType_MAXPOOL = 3,
  Edge_EdgeType_RESPONSE_NORM = 4,
  Edge_EdgeType_UPSAMPLE = 5,
  Edge_EdgeType_DOWNSAMPLE = 6,
  Edge_EdgeType_RGBTOYUV = 7,
  Edge_EdgeType_AVERAGE_POOL = 8
};
bool Edge_EdgeType_IsValid(int value);
const Edge_EdgeType Edge_EdgeType_EdgeType_MIN = Edge_EdgeType_FC;
const Edge_EdgeType Edge_EdgeType_EdgeType_MAX = Edge_EdgeType_AVERAGE_POOL;
const int Edge_EdgeType_EdgeType_ARRAYSIZE = Edge_EdgeType_EdgeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Edge_EdgeType_descriptor();
inline const ::std::string& Edge_EdgeType_Name(Edge_EdgeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Edge_EdgeType_descriptor(), value);
}
inline bool Edge_EdgeType_Parse(
    const ::std::string& name, Edge_EdgeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Edge_EdgeType>(
    Edge_EdgeType_descriptor(), name, value);
}
enum Edge_Initialization {
  Edge_Initialization_DENSE_GAUSSIAN = 0,
  Edge_Initialization_SPARSE_GAUSSIAN = 1,
  Edge_Initialization_CONSTANT = 2,
  Edge_Initialization_DENSE_GAUSSIAN_SQRT_FAN_IN = 3,
  Edge_Initialization_PRETRAINED = 4,
  Edge_Initialization_DENSE_UNIFORM = 5,
  Edge_Initialization_DENSE_UNIFORM_SQRT_FAN_IN = 6
};
bool Edge_Initialization_IsValid(int value);
const Edge_Initialization Edge_Initialization_Initialization_MIN = Edge_Initialization_DENSE_GAUSSIAN;
const Edge_Initialization Edge_Initialization_Initialization_MAX = Edge_Initialization_DENSE_UNIFORM_SQRT_FAN_IN;
const int Edge_Initialization_Initialization_ARRAYSIZE = Edge_Initialization_Initialization_MAX + 1;

const ::google::protobuf::EnumDescriptor* Edge_Initialization_descriptor();
inline const ::std::string& Edge_Initialization_Name(Edge_Initialization value) {
  return ::google::protobuf::internal::NameOfEnum(
    Edge_Initialization_descriptor(), value);
}
inline bool Edge_Initialization_Parse(
    const ::std::string& name, Edge_Initialization* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Edge_Initialization>(
    Edge_Initialization_descriptor(), name, value);
}
enum DatasetConfig_DatasetType {
  DatasetConfig_DatasetType_DUMMY = 0,
  DatasetConfig_DatasetType_IMAGE_HDF5 = 1,
  DatasetConfig_DatasetType_IMAGE_HDF5_MULT_POS = 2,
  DatasetConfig_DatasetType_IMAGENET_CLS_HDF5 = 3,
  DatasetConfig_DatasetType_IMAGENET_CLS_HDF5_MULT_POS = 4,
  DatasetConfig_DatasetType_RAW_IMAGE = 5,
  DatasetConfig_DatasetType_HDF5 = 6,
  DatasetConfig_DatasetType_IMAGE_POS_NEG_HDF5 = 7,
  DatasetConfig_DatasetType_RAW_IMAGE_SLIDING_WINDOW = 8
};
bool DatasetConfig_DatasetType_IsValid(int value);
const DatasetConfig_DatasetType DatasetConfig_DatasetType_DatasetType_MIN = DatasetConfig_DatasetType_DUMMY;
const DatasetConfig_DatasetType DatasetConfig_DatasetType_DatasetType_MAX = DatasetConfig_DatasetType_RAW_IMAGE_SLIDING_WINDOW;
const int DatasetConfig_DatasetType_DatasetType_ARRAYSIZE = DatasetConfig_DatasetType_DatasetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DatasetConfig_DatasetType_descriptor();
inline const ::std::string& DatasetConfig_DatasetType_Name(DatasetConfig_DatasetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DatasetConfig_DatasetType_descriptor(), value);
}
inline bool DatasetConfig_DatasetType_Parse(
    const ::std::string& name, DatasetConfig_DatasetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatasetConfig_DatasetType>(
    DatasetConfig_DatasetType_descriptor(), name, value);
}
// ===================================================================

class Layer : public ::google::protobuf::Message {
 public:
  Layer();
  virtual ~Layer();

  Layer(const Layer& from);

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layer& default_instance();

  void Swap(Layer* other);

  // implements Message ----------------------------------------------

  Layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Layer_Activation Activation;
  static const Activation LINEAR = Layer_Activation_LINEAR;
  static const Activation LOGISTIC = Layer_Activation_LOGISTIC;
  static const Activation RECTIFIED_LINEAR = Layer_Activation_RECTIFIED_LINEAR;
  static const Activation SOFTMAX = Layer_Activation_SOFTMAX;
  static const Activation SOFTMAX_DIST = Layer_Activation_SOFTMAX_DIST;
  static inline bool Activation_IsValid(int value) {
    return Layer_Activation_IsValid(value);
  }
  static const Activation Activation_MIN =
    Layer_Activation_Activation_MIN;
  static const Activation Activation_MAX =
    Layer_Activation_Activation_MAX;
  static const int Activation_ARRAYSIZE =
    Layer_Activation_Activation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Activation_descriptor() {
    return Layer_Activation_descriptor();
  }
  static inline const ::std::string& Activation_Name(Activation value) {
    return Layer_Activation_Name(value);
  }
  static inline bool Activation_Parse(const ::std::string& name,
      Activation* value) {
    return Layer_Activation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 num_channels = 2;
  inline bool has_num_channels() const;
  inline void clear_num_channels();
  static const int kNumChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 num_channels() const;
  inline void set_num_channels(::google::protobuf::int32 value);

  // optional int32 size = 3 [default = -1];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional float dropprob = 4 [default = 0];
  inline bool has_dropprob() const;
  inline void clear_dropprob();
  static const int kDropprobFieldNumber = 4;
  inline float dropprob() const;
  inline void set_dropprob(float value);

  // optional bool is_input = 5 [default = false];
  inline bool has_is_input() const;
  inline void clear_is_input();
  static const int kIsInputFieldNumber = 5;
  inline bool is_input() const;
  inline void set_is_input(bool value);

  // optional .config.Layer.Activation activation = 6 [default = LINEAR];
  inline bool has_activation() const;
  inline void clear_activation();
  static const int kActivationFieldNumber = 6;
  inline ::config::Layer_Activation activation() const;
  inline void set_activation(::config::Layer_Activation value);

  // optional bool is_spatial_output = 7 [default = false];
  inline bool has_is_spatial_output() const;
  inline void clear_is_spatial_output();
  static const int kIsSpatialOutputFieldNumber = 7;
  inline bool is_spatial_output() const;
  inline void set_is_spatial_output(bool value);

  // optional bool is_classifier_output = 8 [default = false];
  inline bool has_is_classifier_output() const;
  inline void clear_is_classifier_output();
  static const int kIsClassifierOutputFieldNumber = 8;
  inline bool is_classifier_output() const;
  inline void set_is_classifier_output(bool value);

  // optional bool display = 9 [default = false];
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 9;
  inline bool display() const;
  inline void set_display(bool value);

  // optional bool is_output = 10 [default = false];
  inline bool has_is_output() const;
  inline void clear_is_output();
  static const int kIsOutputFieldNumber = 10;
  inline bool is_output() const;
  inline void set_is_output(bool value);

  // optional bool gaussian_dropout = 11 [default = false];
  inline bool has_gaussian_dropout() const;
  inline void clear_gaussian_dropout();
  static const int kGaussianDropoutFieldNumber = 11;
  inline bool gaussian_dropout() const;
  inline void set_gaussian_dropout(bool value);

  // optional float max_act_gaussian_dropout = 12 [default = -1];
  inline bool has_max_act_gaussian_dropout() const;
  inline void clear_max_act_gaussian_dropout();
  static const int kMaxActGaussianDropoutFieldNumber = 12;
  inline float max_act_gaussian_dropout() const;
  inline void set_max_act_gaussian_dropout(float value);

  // optional int32 gpu_id = 13 [default = 0];
  inline bool has_gpu_id() const;
  inline void clear_gpu_id();
  static const int kGpuIdFieldNumber = 13;
  inline ::google::protobuf::int32 gpu_id() const;
  inline void set_gpu_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:config.Layer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_num_channels();
  inline void clear_has_num_channels();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_dropprob();
  inline void clear_has_dropprob();
  inline void set_has_is_input();
  inline void clear_has_is_input();
  inline void set_has_activation();
  inline void clear_has_activation();
  inline void set_has_is_spatial_output();
  inline void clear_has_is_spatial_output();
  inline void set_has_is_classifier_output();
  inline void clear_has_is_classifier_output();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_is_output();
  inline void clear_has_is_output();
  inline void set_has_gaussian_dropout();
  inline void clear_has_gaussian_dropout();
  inline void set_has_max_act_gaussian_dropout();
  inline void clear_has_max_act_gaussian_dropout();
  inline void set_has_gpu_id();
  inline void clear_has_gpu_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 num_channels_;
  ::google::protobuf::int32 size_;
  float dropprob_;
  int activation_;
  bool is_input_;
  bool is_spatial_output_;
  bool is_classifier_output_;
  bool display_;
  bool is_output_;
  bool gaussian_dropout_;
  float max_act_gaussian_dropout_;
  ::google::protobuf::int32 gpu_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_convnet_5fconfig_2eproto();
  friend void protobuf_AssignDesc_convnet_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_convnet_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// -------------------------------------------------------------------

class Optimizer : public ::google::protobuf::Message {
 public:
  Optimizer();
  virtual ~Optimizer();

  Optimizer(const Optimizer& from);

  inline Optimizer& operator=(const Optimizer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Optimizer& default_instance();

  void Swap(Optimizer* other);

  // implements Message ----------------------------------------------

  Optimizer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Optimizer& from);
  void MergeFrom(const Optimizer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Optimizer_OptimizerType OptimizerType;
  static const OptimizerType STOCHASTIC_GRADIENT_DESCENT = Optimizer_OptimizerType_STOCHASTIC_GRADIENT_DESCENT;
  static const OptimizerType LBFGS = Optimizer_OptimizerType_LBFGS;
  static inline bool OptimizerType_IsValid(int value) {
    return Optimizer_OptimizerType_IsValid(value);
  }
  static const OptimizerType OptimizerType_MIN =
    Optimizer_OptimizerType_OptimizerType_MIN;
  static const OptimizerType OptimizerType_MAX =
    Optimizer_OptimizerType_OptimizerType_MAX;
  static const int OptimizerType_ARRAYSIZE =
    Optimizer_OptimizerType_OptimizerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OptimizerType_descriptor() {
    return Optimizer_OptimizerType_descriptor();
  }
  static inline const ::std::string& OptimizerType_Name(OptimizerType value) {
    return Optimizer_OptimizerType_Name(value);
  }
  static inline bool OptimizerType_Parse(const ::std::string& name,
      OptimizerType* value) {
    return Optimizer_OptimizerType_Parse(name, value);
  }

  typedef Optimizer_Decay Decay;
  static const Decay NONE = Optimizer_Decay_NONE;
  static const Decay INVERSE_T = Optimizer_Decay_INVERSE_T;
  static const Decay EXPONENTIAL = Optimizer_Decay_EXPONENTIAL;
  static const Decay LINEAR = Optimizer_Decay_LINEAR;
  static inline bool Decay_IsValid(int value) {
    return Optimizer_Decay_IsValid(value);
  }
  static const Decay Decay_MIN =
    Optimizer_Decay_Decay_MIN;
  static const Decay Decay_MAX =
    Optimizer_Decay_Decay_MAX;
  static const int Decay_ARRAYSIZE =
    Optimizer_Decay_Decay_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Decay_descriptor() {
    return Optimizer_Decay_descriptor();
  }
  static inline const ::std::string& Decay_Name(Decay value) {
    return Optimizer_Decay_Name(value);
  }
  static inline bool Decay_Parse(const ::std::string& name,
      Decay* value) {
    return Optimizer_Decay_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .config.Optimizer.OptimizerType optimizer_type = 1 [default = STOCHASTIC_GRADIENT_DESCENT];
  inline bool has_optimizer_type() const;
  inline void clear_optimizer_type();
  static const int kOptimizerTypeFieldNumber = 1;
  inline ::config::Optimizer_OptimizerType optimizer_type() const;
  inline void set_optimizer_type(::config::Optimizer_OptimizerType value);

  // optional float epsilon = 2 [default = 0];
  inline bool has_epsilon() const;
  inline void clear_epsilon();
  static const int kEpsilonFieldNumber = 2;
  inline float epsilon() const;
  inline void set_epsilon(float value);

  // optional int32 epsilon_decay_timescale = 3 [default = 0];
  inline bool has_epsilon_decay_timescale() const;
  inline void clear_epsilon_decay_timescale();
  static const int kEpsilonDecayTimescaleFieldNumber = 3;
  inline ::google::protobuf::int32 epsilon_decay_timescale() const;
  inline void set_epsilon_decay_timescale(::google::protobuf::int32 value);

  // optional float initial_momentum = 4 [default = 0];
  inline bool has_initial_momentum() const;
  inline void clear_initial_momentum();
  static const int kInitialMomentumFieldNumber = 4;
  inline float initial_momentum() const;
  inline void set_initial_momentum(float value);

  // optional float final_momentum = 5 [default = 0];
  inline bool has_final_momentum() const;
  inline void clear_final_momentum();
  static const int kFinalMomentumFieldNumber = 5;
  inline float final_momentum() const;
  inline void set_final_momentum(float value);

  // optional int32 momentum_transition_timescale = 6 [default = 0];
  inline bool has_momentum_transition_timescale() const;
  inline void clear_momentum_transition_timescale();
  static const int kMomentumTransitionTimescaleFieldNumber = 6;
  inline ::google::protobuf::int32 momentum_transition_timescale() const;
  inline void set_momentum_transition_timescale(::google::protobuf::int32 value);

  // optional float l2_decay = 7 [default = 0];
  inline bool has_l2_decay() const;
  inline void clear_l2_decay();
  static const int kL2DecayFieldNumber = 7;
  inline float l2_decay() const;
  inline void set_l2_decay(float value);

  // optional float weight_norm_limit = 8 [default = 0];
  inline bool has_weight_norm_limit() const;
  inline void clear_weight_norm_limit();
  static const int kWeightNormLimitFieldNumber = 8;
  inline float weight_norm_limit() const;
  inline void set_weight_norm_limit(float value);

  // optional float weight_norm_constraint = 9 [default = 0];
  inline bool has_weight_norm_constraint() const;
  inline void clear_weight_norm_constraint();
  static const int kWeightNormConstraintFieldNumber = 9;
  inline float weight_norm_constraint() const;
  inline void set_weight_norm_constraint(float value);

  // optional .config.Optimizer.Decay epsilon_decay = 10 [default = NONE];
  inline bool has_epsilon_decay() const;
  inline void clear_epsilon_decay();
  static const int kEpsilonDecayFieldNumber = 10;
  inline ::config::Optimizer_Decay epsilon_decay() const;
  inline void set_epsilon_decay(::config::Optimizer_Decay value);

  // optional float minimum_epsilon = 11 [default = 0];
  inline bool has_minimum_epsilon() const;
  inline void clear_minimum_epsilon();
  static const int kMinimumEpsilonFieldNumber = 11;
  inline float minimum_epsilon() const;
  inline void set_minimum_epsilon(float value);

  // optional float gradient_clip = 12 [default = -1];
  inline bool has_gradient_clip() const;
  inline void clear_gradient_clip();
  static const int kGradientClipFieldNumber = 12;
  inline float gradient_clip() const;
  inline void set_gradient_clip(float value);

  // optional int32 lbfgs_memory = 13 [default = 0];
  inline bool has_lbfgs_memory() const;
  inline void clear_lbfgs_memory();
  static const int kLbfgsMemoryFieldNumber = 13;
  inline ::google::protobuf::int32 lbfgs_memory() const;
  inline void set_lbfgs_memory(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:config.Optimizer)
 private:
  inline void set_has_optimizer_type();
  inline void clear_has_optimizer_type();
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  inline void set_has_epsilon_decay_timescale();
  inline void clear_has_epsilon_decay_timescale();
  inline void set_has_initial_momentum();
  inline void clear_has_initial_momentum();
  inline void set_has_final_momentum();
  inline void clear_has_final_momentum();
  inline void set_has_momentum_transition_timescale();
  inline void clear_has_momentum_transition_timescale();
  inline void set_has_l2_decay();
  inline void clear_has_l2_decay();
  inline void set_has_weight_norm_limit();
  inline void clear_has_weight_norm_limit();
  inline void set_has_weight_norm_constraint();
  inline void clear_has_weight_norm_constraint();
  inline void set_has_epsilon_decay();
  inline void clear_has_epsilon_decay();
  inline void set_has_minimum_epsilon();
  inline void clear_has_minimum_epsilon();
  inline void set_has_gradient_clip();
  inline void clear_has_gradient_clip();
  inline void set_has_lbfgs_memory();
  inline void clear_has_lbfgs_memory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int optimizer_type_;
  float epsilon_;
  ::google::protobuf::int32 epsilon_decay_timescale_;
  float initial_momentum_;
  float final_momentum_;
  ::google::protobuf::int32 momentum_transition_timescale_;
  float l2_decay_;
  float weight_norm_limit_;
  float weight_norm_constraint_;
  int epsilon_decay_;
  float minimum_epsilon_;
  float gradient_clip_;
  ::google::protobuf::int32 lbfgs_memory_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_convnet_5fconfig_2eproto();
  friend void protobuf_AssignDesc_convnet_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_convnet_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static Optimizer* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  Edge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Edge_EdgeType EdgeType;
  static const EdgeType FC = Edge_EdgeType_FC;
  static const EdgeType CONVOLUTIONAL = Edge_EdgeType_CONVOLUTIONAL;
  static const EdgeType LOCAL = Edge_EdgeType_LOCAL;
  static const EdgeType MAXPOOL = Edge_EdgeType_MAXPOOL;
  static const EdgeType RESPONSE_NORM = Edge_EdgeType_RESPONSE_NORM;
  static const EdgeType UPSAMPLE = Edge_EdgeType_UPSAMPLE;
  static const EdgeType DOWNSAMPLE = Edge_EdgeType_DOWNSAMPLE;
  static const EdgeType RGBTOYUV = Edge_EdgeType_RGBTOYUV;
  static const EdgeType AVERAGE_POOL = Edge_EdgeType_AVERAGE_POOL;
  static inline bool EdgeType_IsValid(int value) {
    return Edge_EdgeType_IsValid(value);
  }
  static const EdgeType EdgeType_MIN =
    Edge_EdgeType_EdgeType_MIN;
  static const EdgeType EdgeType_MAX =
    Edge_EdgeType_EdgeType_MAX;
  static const int EdgeType_ARRAYSIZE =
    Edge_EdgeType_EdgeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EdgeType_descriptor() {
    return Edge_EdgeType_descriptor();
  }
  static inline const ::std::string& EdgeType_Name(EdgeType value) {
    return Edge_EdgeType_Name(value);
  }
  static inline bool EdgeType_Parse(const ::std::string& name,
      EdgeType* value) {
    return Edge_EdgeType_Parse(name, value);
  }

  typedef Edge_Initialization Initialization;
  static const Initialization DENSE_GAUSSIAN = Edge_Initialization_DENSE_GAUSSIAN;
  static const Initialization SPARSE_GAUSSIAN = Edge_Initialization_SPARSE_GAUSSIAN;
  static const Initialization CONSTANT = Edge_Initialization_CONSTANT;
  static const Initialization DENSE_GAUSSIAN_SQRT_FAN_IN = Edge_Initialization_DENSE_GAUSSIAN_SQRT_FAN_IN;
  static const Initialization PRETRAINED = Edge_Initialization_PRETRAINED;
  static const Initialization DENSE_UNIFORM = Edge_Initialization_DENSE_UNIFORM;
  static const Initialization DENSE_UNIFORM_SQRT_FAN_IN = Edge_Initialization_DENSE_UNIFORM_SQRT_FAN_IN;
  static inline bool Initialization_IsValid(int value) {
    return Edge_Initialization_IsValid(value);
  }
  static const Initialization Initialization_MIN =
    Edge_Initialization_Initialization_MIN;
  static const Initialization Initialization_MAX =
    Edge_Initialization_Initialization_MAX;
  static const int Initialization_ARRAYSIZE =
    Edge_Initialization_Initialization_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Initialization_descriptor() {
    return Edge_Initialization_descriptor();
  }
  static inline const ::std::string& Initialization_Name(Initialization value) {
    return Edge_Initialization_Name(value);
  }
  static inline bool Initialization_Parse(const ::std::string& name,
      Initialization* value) {
    return Edge_Initialization_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // required string dest = 2;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 2;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  inline void set_allocated_dest(::std::string* dest);

  // optional .config.Edge.EdgeType edge_type = 3 [default = FC];
  inline bool has_edge_type() const;
  inline void clear_edge_type();
  static const int kEdgeTypeFieldNumber = 3;
  inline ::config::Edge_EdgeType edge_type() const;
  inline void set_edge_type(::config::Edge_EdgeType value);

  // optional int32 kernel_size = 4 [default = 1];
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 4;
  inline ::google::protobuf::int32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::int32 value);

  // optional int32 stride = 5 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 5;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);

  // optional int32 padding = 6 [default = 0];
  inline bool has_padding() const;
  inline void clear_padding();
  static const int kPaddingFieldNumber = 6;
  inline ::google::protobuf::int32 padding() const;
  inline void set_padding(::google::protobuf::int32 value);

  // optional .config.Edge.Initialization initialization = 7 [default = DENSE_GAUSSIAN_SQRT_FAN_IN];
  inline bool has_initialization() const;
  inline void clear_initialization();
  static const int kInitializationFieldNumber = 7;
  inline ::config::Edge_Initialization initialization() const;
  inline void set_initialization(::config::Edge_Initialization value);

  // optional float init_wt = 8 [default = 1];
  inline bool has_init_wt() const;
  inline void clear_init_wt();
  static const int kInitWtFieldNumber = 8;
  inline float init_wt() const;
  inline void set_init_wt(float value);

  // optional float init_bias = 9 [default = 0];
  inline bool has_init_bias() const;
  inline void clear_init_bias();
  static const int kInitBiasFieldNumber = 9;
  inline float init_bias() const;
  inline void set_init_bias(float value);

  // optional .config.Optimizer weight_optimizer = 10;
  inline bool has_weight_optimizer() const;
  inline void clear_weight_optimizer();
  static const int kWeightOptimizerFieldNumber = 10;
  inline const ::config::Optimizer& weight_optimizer() const;
  inline ::config::Optimizer* mutable_weight_optimizer();
  inline ::config::Optimizer* release_weight_optimizer();
  inline void set_allocated_weight_optimizer(::config::Optimizer* weight_optimizer);

  // optional .config.Optimizer bias_optimizer = 11;
  inline bool has_bias_optimizer() const;
  inline void clear_bias_optimizer();
  static const int kBiasOptimizerFieldNumber = 11;
  inline const ::config::Optimizer& bias_optimizer() const;
  inline ::config::Optimizer* mutable_bias_optimizer();
  inline ::config::Optimizer* release_bias_optimizer();
  inline void set_allocated_bias_optimizer(::config::Optimizer* bias_optimizer);

  // optional bool shared_bias = 12 [default = false];
  inline bool has_shared_bias() const;
  inline void clear_shared_bias();
  static const int kSharedBiasFieldNumber = 12;
  inline bool shared_bias() const;
  inline void set_shared_bias(bool value);

  // optional bool block_backprop = 13 [default = false];
  inline bool has_block_backprop() const;
  inline void clear_block_backprop();
  static const int kBlockBackpropFieldNumber = 13;
  inline bool block_backprop() const;
  inline void set_block_backprop(bool value);

  // optional string tied_to = 14;
  inline bool has_tied_to() const;
  inline void clear_tied_to();
  static const int kTiedToFieldNumber = 14;
  inline const ::std::string& tied_to() const;
  inline void set_tied_to(const ::std::string& value);
  inline void set_tied_to(const char* value);
  inline void set_tied_to(const char* value, size_t size);
  inline ::std::string* mutable_tied_to();
  inline ::std::string* release_tied_to();
  inline void set_allocated_tied_to(::std::string* tied_to);

  // optional bool has_no_bias = 15 [default = false];
  inline bool has_has_no_bias() const;
  inline void clear_has_no_bias();
  static const int kHasNoBiasFieldNumber = 15;
  inline bool has_no_bias() const;
  inline void set_has_no_bias(bool value);

  // optional float scale_gradients = 16 [default = 1];
  inline bool has_scale_gradients() const;
  inline void clear_scale_gradients();
  static const int kScaleGradientsFieldNumber = 16;
  inline float scale_gradients() const;
  inline void set_scale_gradients(float value);

  // optional int32 partial_sum = 17 [default = 0];
  inline bool has_partial_sum() const;
  inline void clear_partial_sum();
  static const int kPartialSumFieldNumber = 17;
  inline ::google::protobuf::int32 partial_sum() const;
  inline void set_partial_sum(::google::protobuf::int32 value);

  // optional int32 sample_factor = 18 [default = 1];
  inline bool has_sample_factor() const;
  inline void clear_sample_factor();
  static const int kSampleFactorFieldNumber = 18;
  inline ::google::protobuf::int32 sample_factor() const;
  inline void set_sample_factor(::google::protobuf::int32 value);

  // optional bool response_norm_in_blocks = 19 [default = false];
  inline bool has_response_norm_in_blocks() const;
  inline void clear_response_norm_in_blocks();
  static const int kResponseNormInBlocksFieldNumber = 19;
  inline bool response_norm_in_blocks() const;
  inline void set_response_norm_in_blocks(bool value);

  // optional float add_scale = 20 [default = 0];
  inline bool has_add_scale() const;
  inline void clear_add_scale();
  static const int kAddScaleFieldNumber = 20;
  inline float add_scale() const;
  inline void set_add_scale(float value);

  // optional float pow_scale = 21 [default = 0];
  inline bool has_pow_scale() const;
  inline void clear_pow_scale();
  static const int kPowScaleFieldNumber = 21;
  inline float pow_scale() const;
  inline void set_pow_scale(float value);

  // optional float frac_of_filters_response_norm = 22 [default = 0];
  inline bool has_frac_of_filters_response_norm() const;
  inline void clear_frac_of_filters_response_norm();
  static const int kFracOfFiltersResponseNormFieldNumber = 22;
  inline float frac_of_filters_response_norm() const;
  inline void set_frac_of_filters_response_norm(float value);

  // optional int32 polyak_queue_size = 23 [default = 0];
  inline bool has_polyak_queue_size() const;
  inline void clear_polyak_queue_size();
  static const int kPolyakQueueSizeFieldNumber = 23;
  inline ::google::protobuf::int32 polyak_queue_size() const;
  inline void set_polyak_queue_size(::google::protobuf::int32 value);

  // optional int32 gpu_id = 24 [default = 0];
  inline bool has_gpu_id() const;
  inline void clear_gpu_id();
  static const int kGpuIdFieldNumber = 24;
  inline ::google::protobuf::int32 gpu_id() const;
  inline void set_gpu_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:config.Edge)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_edge_type();
  inline void clear_has_edge_type();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_padding();
  inline void clear_has_padding();
  inline void set_has_initialization();
  inline void clear_has_initialization();
  inline void set_has_init_wt();
  inline void clear_has_init_wt();
  inline void set_has_init_bias();
  inline void clear_has_init_bias();
  inline void set_has_weight_optimizer();
  inline void clear_has_weight_optimizer();
  inline void set_has_bias_optimizer();
  inline void clear_has_bias_optimizer();
  inline void set_has_shared_bias();
  inline void clear_has_shared_bias();
  inline void set_has_block_backprop();
  inline void clear_has_block_backprop();
  inline void set_has_tied_to();
  inline void clear_has_tied_to();
  inline void set_has_has_no_bias();
  inline void clear_has_has_no_bias();
  inline void set_has_scale_gradients();
  inline void clear_has_scale_gradients();
  inline void set_has_partial_sum();
  inline void clear_has_partial_sum();
  inline void set_has_sample_factor();
  inline void clear_has_sample_factor();
  inline void set_has_response_norm_in_blocks();
  inline void clear_has_response_norm_in_blocks();
  inline void set_has_add_scale();
  inline void clear_has_add_scale();
  inline void set_has_pow_scale();
  inline void clear_has_pow_scale();
  inline void set_has_frac_of_filters_response_norm();
  inline void clear_has_frac_of_filters_response_norm();
  inline void set_has_polyak_queue_size();
  inline void clear_has_polyak_queue_size();
  inline void set_has_gpu_id();
  inline void clear_has_gpu_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* source_;
  ::std::string* dest_;
  int edge_type_;
  ::google::protobuf::int32 kernel_size_;
  ::google::protobuf::int32 stride_;
  ::google::protobuf::int32 padding_;
  int initialization_;
  float init_wt_;
  ::config::Optimizer* weight_optimizer_;
  ::config::Optimizer* bias_optimizer_;
  float init_bias_;
  bool shared_bias_;
  bool block_backprop_;
  bool has_no_bias_;
  bool response_norm_in_blocks_;
  ::std::string* tied_to_;
  float scale_gradients_;
  ::google::protobuf::int32 partial_sum_;
  ::google::protobuf::int32 sample_factor_;
  float add_scale_;
  float pow_scale_;
  float frac_of_filters_response_norm_;
  ::google::protobuf::int32 polyak_queue_size_;
  ::google::protobuf::int32 gpu_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void  protobuf_AddDesc_convnet_5fconfig_2eproto();
  friend void protobuf_AssignDesc_convnet_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_convnet_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  void Swap(Model* other);

  // implements Message ----------------------------------------------

  Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .config.Layer layer = 2;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 2;
  inline const ::config::Layer& layer(int index) const;
  inline ::config::Layer* mutable_layer(int index);
  inline ::config::Layer* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::config::Layer >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::config::Layer >*
      mutable_layer();

  // repeated .config.Edge edge = 3;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 3;
  inline const ::config::Edge& edge(int index) const;
  inline ::config::Edge* mutable_edge(int index);
  inline ::config::Edge* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::config::Edge >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::config::Edge >*
      mutable_edge();

  // required int32 seed = 4;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 4;
  inline ::google::protobuf::int32 seed() const;
  inline void set_seed(::google::protobuf::int32 value);

  // optional int32 max_iter = 5 [default = -1];
  inline bool has_max_iter() const;
  inline void clear_max_iter();
  static const int kMaxIterFieldNumber = 5;
  inline ::google::protobuf::int32 max_iter() const;
  inline void set_max_iter(::google::protobuf::int32 value);

  // optional int32 display_after = 6 [default = -1];
  inline bool has_display_after() const;
  inline void clear_display_after();
  static const int kDisplayAfterFieldNumber = 6;
  inline ::google::protobuf::int32 display_after() const;
  inline void set_display_after(::google::protobuf::int32 value);

  // optional int32 save_after = 7 [default = -1];
  inline bool has_save_after() const;
  inline void clear_save_after();
  static const int kSaveAfterFieldNumber = 7;
  inline ::google::protobuf::int32 save_after() const;
  inline void set_save_after(::google::protobuf::int32 value);

  // optional int32 image_size = 8 [default = 0];
  inline bool has_image_size() const;
  inline void clear_image_size();
  static const int kImageSizeFieldNumber = 8;
  inline ::google::protobuf::int32 image_size() const;
  inline void set_image_size(::google::protobuf::int32 value);

  // optional int32 patch_size = 9 [default = 0];
  inline bool has_patch_size() const;
  inline void clear_patch_size();
  static const int kPatchSizeFieldNumber = 9;
  inline ::google::protobuf::int32 patch_size() const;
  inline void set_patch_size(::google::protobuf::int32 value);

  // optional int32 print_after = 10 [default = -1];
  inline bool has_print_after() const;
  inline void clear_print_after();
  static const int kPrintAfterFieldNumber = 10;
  inline ::google::protobuf::int32 print_after() const;
  inline void set_print_after(::google::protobuf::int32 value);

  // optional int32 current_iter = 11 [default = 0];
  inline bool has_current_iter() const;
  inline void clear_current_iter();
  static const int kCurrentIterFieldNumber = 11;
  inline ::google::protobuf::int32 current_iter() const;
  inline void set_current_iter(::google::protobuf::int32 value);

  // optional string checkpoint_dir = 12;
  inline bool has_checkpoint_dir() const;
  inline void clear_checkpoint_dir();
  static const int kCheckpointDirFieldNumber = 12;
  inline const ::std::string& checkpoint_dir() const;
  inline void set_checkpoint_dir(const ::std::string& value);
  inline void set_checkpoint_dir(const char* value);
  inline void set_checkpoint_dir(const char* value, size_t size);
  inline ::std::string* mutable_checkpoint_dir();
  inline ::std::string* release_checkpoint_dir();
  inline void set_allocated_checkpoint_dir(::std::string* checkpoint_dir);

  // optional bool has_spatial_outputs = 13 [default = false];
  inline bool has_has_spatial_outputs() const;
  inline void clear_has_spatial_outputs();
  static const int kHasSpatialOutputsFieldNumber = 13;
  inline bool has_spatial_outputs() const;
  inline void set_has_spatial_outputs(bool value);

  // optional bool display_spatial_output = 14 [default = false];
  inline bool has_display_spatial_output() const;
  inline void clear_display_spatial_output();
  static const int kDisplaySpatialOutputFieldNumber = 14;
  inline bool display_spatial_output() const;
  inline void set_display_spatial_output(bool value);

  // repeated string timestamp = 15;
  inline int timestamp_size() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 15;
  inline const ::std::string& timestamp(int index) const;
  inline ::std::string* mutable_timestamp(int index);
  inline void set_timestamp(int index, const ::std::string& value);
  inline void set_timestamp(int index, const char* value);
  inline void set_timestamp(int index, const char* value, size_t size);
  inline ::std::string* add_timestamp();
  inline void add_timestamp(const ::std::string& value);
  inline void add_timestamp(const char* value);
  inline void add_timestamp(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& timestamp() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_timestamp();

  // optional bool det_classifier = 16 [default = false];
  inline bool has_det_classifier() const;
  inline void clear_det_classifier();
  static const int kDetClassifierFieldNumber = 16;
  inline bool det_classifier() const;
  inline void set_det_classifier(bool value);

  // optional bool display = 17 [default = false];
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 17;
  inline bool display() const;
  inline void set_display(bool value);

  // optional int32 validate_after = 18 [default = -1];
  inline bool has_validate_after() const;
  inline void clear_validate_after();
  static const int kValidateAfterFieldNumber = 18;
  inline ::google::protobuf::int32 validate_after() const;
  inline void set_validate_after(::google::protobuf::int32 value);

  // optional float reduce_lr_factor = 19 [default = 1];
  inline bool has_reduce_lr_factor() const;
  inline void clear_reduce_lr_factor();
  static const int kReduceLrFactorFieldNumber = 19;
  inline float reduce_lr_factor() const;
  inline void set_reduce_lr_factor(float value);

  // optional float reduce_lr_threshold = 20 [default = 0];
  inline bool has_reduce_lr_threshold() const;
  inline void clear_reduce_lr_threshold();
  static const int kReduceLrThresholdFieldNumber = 20;
  inline float reduce_lr_threshold() const;
  inline void set_reduce_lr_threshold(float value);

  // optional int32 reduce_lr_num_steps = 21 [default = 0];
  inline bool has_reduce_lr_num_steps() const;
  inline void clear_reduce_lr_num_steps();
  static const int kReduceLrNumStepsFieldNumber = 21;
  inline ::google::protobuf::int32 reduce_lr_num_steps() const;
  inline void set_reduce_lr_num_steps(::google::protobuf::int32 value);

  // optional int32 reduce_lr_max = 22 [default = 0];
  inline bool has_reduce_lr_max() const;
  inline void clear_reduce_lr_max();
  static const int kReduceLrMaxFieldNumber = 22;
  inline ::google::protobuf::int32 reduce_lr_max() const;
  inline void set_reduce_lr_max(::google::protobuf::int32 value);

  // optional bool smaller_is_better = 23 [default = false];
  inline bool has_smaller_is_better() const;
  inline void clear_smaller_is_better();
  static const int kSmallerIsBetterFieldNumber = 23;
  inline bool smaller_is_better() const;
  inline void set_smaller_is_better(bool value);

  // optional int32 polyak_after = 24 [default = 0];
  inline bool has_polyak_after() const;
  inline void clear_polyak_after();
  static const int kPolyakAfterFieldNumber = 24;
  inline ::google::protobuf::int32 polyak_after() const;
  inline void set_polyak_after(::google::protobuf::int32 value);

  // optional int32 polyak_queue_size = 25 [default = 0];
  inline bool has_polyak_queue_size() const;
  inline void clear_polyak_queue_size();
  static const int kPolyakQueueSizeFieldNumber = 25;
  inline ::google::protobuf::int32 polyak_queue_size() const;
  inline void set_polyak_queue_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:config.Model)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_max_iter();
  inline void clear_has_max_iter();
  inline void set_has_display_after();
  inline void clear_has_display_after();
  inline void set_has_save_after();
  inline void clear_has_save_after();
  inline void set_has_image_size();
  inline void clear_has_image_size();
  inline void set_has_patch_size();
  inline void clear_has_patch_size();
  inline void set_has_print_after();
  inline void clear_has_print_after();
  inline void set_has_current_iter();
  inline void clear_has_current_iter();
  inline void set_has_checkpoint_dir();
  inline void clear_has_checkpoint_dir();
  inline void set_has_has_spatial_outputs();
  inline void clear_has_has_spatial_outputs();
  inline void set_has_display_spatial_output();
  inline void clear_has_display_spatial_output();
  inline void set_has_det_classifier();
  inline void clear_has_det_classifier();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_validate_after();
  inline void clear_has_validate_after();
  inline void set_has_reduce_lr_factor();
  inline void clear_has_reduce_lr_factor();
  inline void set_has_reduce_lr_threshold();
  inline void clear_has_reduce_lr_threshold();
  inline void set_has_reduce_lr_num_steps();
  inline void clear_has_reduce_lr_num_steps();
  inline void set_has_reduce_lr_max();
  inline void clear_has_reduce_lr_max();
  inline void set_has_smaller_is_better();
  inline void clear_has_smaller_is_better();
  inline void set_has_polyak_after();
  inline void clear_has_polyak_after();
  inline void set_has_polyak_queue_size();
  inline void clear_has_polyak_queue_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::config::Layer > layer_;
  ::google::protobuf::RepeatedPtrField< ::config::Edge > edge_;
  ::google::protobuf::int32 seed_;
  ::google::protobuf::int32 max_iter_;
  ::google::protobuf::int32 display_after_;
  ::google::protobuf::int32 save_after_;
  ::google::protobuf::int32 image_size_;
  ::google::protobuf::int32 patch_size_;
  ::google::protobuf::int32 print_after_;
  ::google::protobuf::int32 current_iter_;
  ::std::string* checkpoint_dir_;
  ::google::protobuf::RepeatedPtrField< ::std::string> timestamp_;
  bool has_spatial_outputs_;
  bool display_spatial_output_;
  bool det_classifier_;
  bool display_;
  ::google::protobuf::int32 validate_after_;
  float reduce_lr_factor_;
  float reduce_lr_threshold_;
  ::google::protobuf::int32 reduce_lr_num_steps_;
  ::google::protobuf::int32 reduce_lr_max_;
  bool smaller_is_better_;
  ::google::protobuf::int32 polyak_after_;
  ::google::protobuf::int32 polyak_queue_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_convnet_5fconfig_2eproto();
  friend void protobuf_AssignDesc_convnet_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_convnet_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class DatasetConfig : public ::google::protobuf::Message {
 public:
  DatasetConfig();
  virtual ~DatasetConfig();

  DatasetConfig(const DatasetConfig& from);

  inline DatasetConfig& operator=(const DatasetConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatasetConfig& default_instance();

  void Swap(DatasetConfig* other);

  // implements Message ----------------------------------------------

  DatasetConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatasetConfig& from);
  void MergeFrom(const DatasetConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DatasetConfig_DatasetType DatasetType;
  static const DatasetType DUMMY = DatasetConfig_DatasetType_DUMMY;
  static const DatasetType IMAGE_HDF5 = DatasetConfig_DatasetType_IMAGE_HDF5;
  static const DatasetType IMAGE_HDF5_MULT_POS = DatasetConfig_DatasetType_IMAGE_HDF5_MULT_POS;
  static const DatasetType IMAGENET_CLS_HDF5 = DatasetConfig_DatasetType_IMAGENET_CLS_HDF5;
  static const DatasetType IMAGENET_CLS_HDF5_MULT_POS = DatasetConfig_DatasetType_IMAGENET_CLS_HDF5_MULT_POS;
  static const DatasetType RAW_IMAGE = DatasetConfig_DatasetType_RAW_IMAGE;
  static const DatasetType HDF5 = DatasetConfig_DatasetType_HDF5;
  static const DatasetType IMAGE_POS_NEG_HDF5 = DatasetConfig_DatasetType_IMAGE_POS_NEG_HDF5;
  static const DatasetType RAW_IMAGE_SLIDING_WINDOW = DatasetConfig_DatasetType_RAW_IMAGE_SLIDING_WINDOW;
  static inline bool DatasetType_IsValid(int value) {
    return DatasetConfig_DatasetType_IsValid(value);
  }
  static const DatasetType DatasetType_MIN =
    DatasetConfig_DatasetType_DatasetType_MIN;
  static const DatasetType DatasetType_MAX =
    DatasetConfig_DatasetType_DatasetType_MAX;
  static const int DatasetType_ARRAYSIZE =
    DatasetConfig_DatasetType_DatasetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DatasetType_descriptor() {
    return DatasetConfig_DatasetType_descriptor();
  }
  static inline const ::std::string& DatasetType_Name(DatasetType value) {
    return DatasetConfig_DatasetType_Name(value);
  }
  static inline bool DatasetType_Parse(const ::std::string& name,
      DatasetType* value) {
    return DatasetConfig_DatasetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string data_dir = 1;
  inline bool has_data_dir() const;
  inline void clear_data_dir();
  static const int kDataDirFieldNumber = 1;
  inline const ::std::string& data_dir() const;
  inline void set_data_dir(const ::std::string& value);
  inline void set_data_dir(const char* value);
  inline void set_data_dir(const char* value, size_t size);
  inline ::std::string* mutable_data_dir();
  inline ::std::string* release_data_dir();
  inline void set_allocated_data_dir(::std::string* data_dir);

  // required .config.DatasetConfig.DatasetType dataset_type = 2;
  inline bool has_dataset_type() const;
  inline void clear_dataset_type();
  static const int kDatasetTypeFieldNumber = 2;
  inline ::config::DatasetConfig_DatasetType dataset_type() const;
  inline void set_dataset_type(::config::DatasetConfig_DatasetType value);

  // optional int32 batch_size = 3 [default = 1];
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 3;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // optional int32 chunk_size = 4 [default = 1];
  inline bool has_chunk_size() const;
  inline void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 4;
  inline ::google::protobuf::int32 chunk_size() const;
  inline void set_chunk_size(::google::protobuf::int32 value);

  // repeated int32 labels = 5;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 5;
  inline ::google::protobuf::int32 labels(int index) const;
  inline void set_labels(int index, ::google::protobuf::int32 value);
  inline void add_labels(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      labels() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_labels();

  // optional int32 max_reuse_count = 6 [default = 0];
  inline bool has_max_reuse_count() const;
  inline void clear_max_reuse_count();
  static const int kMaxReuseCountFieldNumber = 6;
  inline ::google::protobuf::int32 max_reuse_count() const;
  inline void set_max_reuse_count(::google::protobuf::int32 value);

  // optional bool pipeline_loads = 7 [default = false];
  inline bool has_pipeline_loads() const;
  inline void clear_pipeline_loads();
  static const int kPipelineLoadsFieldNumber = 7;
  inline bool pipeline_loads() const;
  inline void set_pipeline_loads(bool value);

  // optional bool randomize_cpu = 8 [default = false];
  inline bool has_randomize_cpu() const;
  inline void clear_randomize_cpu();
  static const int kRandomizeCpuFieldNumber = 8;
  inline bool randomize_cpu() const;
  inline void set_randomize_cpu(bool value);

  // optional string mean_image_file = 9;
  inline bool has_mean_image_file() const;
  inline void clear_mean_image_file();
  static const int kMeanImageFileFieldNumber = 9;
  inline const ::std::string& mean_image_file() const;
  inline void set_mean_image_file(const ::std::string& value);
  inline void set_mean_image_file(const char* value);
  inline void set_mean_image_file(const char* value, size_t size);
  inline ::std::string* mutable_mean_image_file();
  inline ::std::string* release_mean_image_file();
  inline void set_allocated_mean_image_file(::std::string* mean_image_file);

  // optional string std_image_file = 10;
  inline bool has_std_image_file() const;
  inline void clear_std_image_file();
  static const int kStdImageFileFieldNumber = 10;
  inline const ::std::string& std_image_file() const;
  inline void set_std_image_file(const ::std::string& value);
  inline void set_std_image_file(const char* value);
  inline void set_std_image_file(const char* value, size_t size);
  inline ::std::string* mutable_std_image_file();
  inline ::std::string* release_std_image_file();
  inline void set_allocated_std_image_file(::std::string* std_image_file);

  // optional int32 image_size = 11;
  inline bool has_image_size() const;
  inline void clear_image_size();
  static const int kImageSizeFieldNumber = 11;
  inline ::google::protobuf::int32 image_size() const;
  inline void set_image_size(::google::protobuf::int32 value);

  // optional bool normalize_images = 12;
  inline bool has_normalize_images() const;
  inline void clear_normalize_images();
  static const int kNormalizeImagesFieldNumber = 12;
  inline bool normalize_images() const;
  inline void set_normalize_images(bool value);

  // optional float pos_frac = 13 [default = 1];
  inline bool has_pos_frac() const;
  inline void clear_pos_frac();
  static const int kPosFracFieldNumber = 13;
  inline float pos_frac() const;
  inline void set_pos_frac(float value);

  // optional bool crop = 14 [default = false];
  inline bool has_crop() const;
  inline void clear_crop();
  static const int kCropFieldNumber = 14;
  inline bool crop() const;
  inline void set_crop(bool value);

  // optional .config.DatasetConfig.DatasetType dataset_val_type = 15;
  inline bool has_dataset_val_type() const;
  inline void clear_dataset_val_type();
  static const int kDatasetValTypeFieldNumber = 15;
  inline ::config::DatasetConfig_DatasetType dataset_val_type() const;
  inline void set_dataset_val_type(::config::DatasetConfig_DatasetType value);

  // optional bool use_sampling = 16;
  inline bool has_use_sampling() const;
  inline void clear_use_sampling();
  static const int kUseSamplingFieldNumber = 16;
  inline bool use_sampling() const;
  inline void set_use_sampling(bool value);

  // optional bool randomize_gpu = 17 [default = false];
  inline bool has_randomize_gpu() const;
  inline void clear_randomize_gpu();
  static const int kRandomizeGpuFieldNumber = 17;
  inline bool randomize_gpu() const;
  inline void set_randomize_gpu(bool value);

  // optional bool warp = 18 [default = false];
  inline bool has_warp() const;
  inline void clear_warp();
  static const int kWarpFieldNumber = 18;
  inline bool warp() const;
  inline void set_warp(bool value);

  // optional bool has_no_labels = 19 [default = false];
  inline bool has_has_no_labels() const;
  inline void clear_has_no_labels();
  static const int kHasNoLabelsFieldNumber = 19;
  inline bool has_no_labels() const;
  inline void set_has_no_labels(bool value);

  // optional string predicted_boxes_file = 20;
  inline bool has_predicted_boxes_file() const;
  inline void clear_predicted_boxes_file();
  static const int kPredictedBoxesFileFieldNumber = 20;
  inline const ::std::string& predicted_boxes_file() const;
  inline void set_predicted_boxes_file(const ::std::string& value);
  inline void set_predicted_boxes_file(const char* value);
  inline void set_predicted_boxes_file(const char* value, size_t size);
  inline ::std::string* mutable_predicted_boxes_file();
  inline ::std::string* release_predicted_boxes_file();
  inline void set_allocated_predicted_boxes_file(::std::string* predicted_boxes_file);

  // optional string file_pattern = 21;
  inline bool has_file_pattern() const;
  inline void clear_file_pattern();
  static const int kFilePatternFieldNumber = 21;
  inline const ::std::string& file_pattern() const;
  inline void set_file_pattern(const ::std::string& value);
  inline void set_file_pattern(const char* value);
  inline void set_file_pattern(const char* value, size_t size);
  inline ::std::string* mutable_file_pattern();
  inline ::std::string* release_file_pattern();
  inline void set_allocated_file_pattern(::std::string* file_pattern);

  // repeated string dataset_name = 22;
  inline int dataset_name_size() const;
  inline void clear_dataset_name();
  static const int kDatasetNameFieldNumber = 22;
  inline const ::std::string& dataset_name(int index) const;
  inline ::std::string* mutable_dataset_name(int index);
  inline void set_dataset_name(int index, const ::std::string& value);
  inline void set_dataset_name(int index, const char* value);
  inline void set_dataset_name(int index, const char* value, size_t size);
  inline ::std::string* add_dataset_name();
  inline void add_dataset_name(const ::std::string& value);
  inline void add_dataset_name(const char* value);
  inline void add_dataset_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& dataset_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dataset_name();

  // optional bool can_translate = 23 [default = false];
  inline bool has_can_translate() const;
  inline void clear_can_translate();
  static const int kCanTranslateFieldNumber = 23;
  inline bool can_translate() const;
  inline void set_can_translate(bool value);

  // optional bool can_flip = 24 [default = false];
  inline bool has_can_flip() const;
  inline void clear_can_flip();
  static const int kCanFlipFieldNumber = 24;
  inline bool can_flip() const;
  inline void set_can_flip(bool value);

  // optional int32 random_access_chunk_size = 25 [default = 1];
  inline bool has_random_access_chunk_size() const;
  inline void clear_random_access_chunk_size();
  static const int kRandomAccessChunkSizeFieldNumber = 25;
  inline ::google::protobuf::int32 random_access_chunk_size() const;
  inline void set_random_access_chunk_size(::google::protobuf::int32 value);

  // optional int32 gpu_id = 26 [default = 0];
  inline bool has_gpu_id() const;
  inline void clear_gpu_id();
  static const int kGpuIdFieldNumber = 26;
  inline ::google::protobuf::int32 gpu_id() const;
  inline void set_gpu_id(::google::protobuf::int32 value);

  // optional int32 max_dataset_size = 27 [default = 0];
  inline bool has_max_dataset_size() const;
  inline void clear_max_dataset_size();
  static const int kMaxDatasetSizeFieldNumber = 27;
  inline ::google::protobuf::int32 max_dataset_size() const;
  inline void set_max_dataset_size(::google::protobuf::int32 value);

  // optional int32 raw_image_size = 28 [default = 0];
  inline bool has_raw_image_size() const;
  inline void clear_raw_image_size();
  static const int kRawImageSizeFieldNumber = 28;
  inline ::google::protobuf::int32 raw_image_size() const;
  inline void set_raw_image_size(::google::protobuf::int32 value);

  // optional int32 stride = 29 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 29;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);

  // optional bool pixelwise_normalize = 30 [default = false];
  inline bool has_pixelwise_normalize() const;
  inline void clear_pixelwise_normalize();
  static const int kPixelwiseNormalizeFieldNumber = 30;
  inline bool pixelwise_normalize() const;
  inline void set_pixelwise_normalize(bool value);

  // optional float pca_noise_stddev = 31 [default = 0];
  inline bool has_pca_noise_stddev() const;
  inline void clear_pca_noise_stddev();
  static const int kPcaNoiseStddevFieldNumber = 31;
  inline float pca_noise_stddev() const;
  inline void set_pca_noise_stddev(float value);

  // @@protoc_insertion_point(class_scope:config.DatasetConfig)
 private:
  inline void set_has_data_dir();
  inline void clear_has_data_dir();
  inline void set_has_dataset_type();
  inline void clear_has_dataset_type();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_chunk_size();
  inline void clear_has_chunk_size();
  inline void set_has_max_reuse_count();
  inline void clear_has_max_reuse_count();
  inline void set_has_pipeline_loads();
  inline void clear_has_pipeline_loads();
  inline void set_has_randomize_cpu();
  inline void clear_has_randomize_cpu();
  inline void set_has_mean_image_file();
  inline void clear_has_mean_image_file();
  inline void set_has_std_image_file();
  inline void clear_has_std_image_file();
  inline void set_has_image_size();
  inline void clear_has_image_size();
  inline void set_has_normalize_images();
  inline void clear_has_normalize_images();
  inline void set_has_pos_frac();
  inline void clear_has_pos_frac();
  inline void set_has_crop();
  inline void clear_has_crop();
  inline void set_has_dataset_val_type();
  inline void clear_has_dataset_val_type();
  inline void set_has_use_sampling();
  inline void clear_has_use_sampling();
  inline void set_has_randomize_gpu();
  inline void clear_has_randomize_gpu();
  inline void set_has_warp();
  inline void clear_has_warp();
  inline void set_has_has_no_labels();
  inline void clear_has_has_no_labels();
  inline void set_has_predicted_boxes_file();
  inline void clear_has_predicted_boxes_file();
  inline void set_has_file_pattern();
  inline void clear_has_file_pattern();
  inline void set_has_can_translate();
  inline void clear_has_can_translate();
  inline void set_has_can_flip();
  inline void clear_has_can_flip();
  inline void set_has_random_access_chunk_size();
  inline void clear_has_random_access_chunk_size();
  inline void set_has_gpu_id();
  inline void clear_has_gpu_id();
  inline void set_has_max_dataset_size();
  inline void clear_has_max_dataset_size();
  inline void set_has_raw_image_size();
  inline void clear_has_raw_image_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_pixelwise_normalize();
  inline void clear_has_pixelwise_normalize();
  inline void set_has_pca_noise_stddev();
  inline void clear_has_pca_noise_stddev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_dir_;
  int dataset_type_;
  ::google::protobuf::int32 batch_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > labels_;
  ::google::protobuf::int32 chunk_size_;
  ::google::protobuf::int32 max_reuse_count_;
  ::std::string* mean_image_file_;
  ::std::string* std_image_file_;
  bool pipeline_loads_;
  bool randomize_cpu_;
  bool normalize_images_;
  bool crop_;
  ::google::protobuf::int32 image_size_;
  float pos_frac_;
  int dataset_val_type_;
  bool use_sampling_;
  bool randomize_gpu_;
  bool warp_;
  bool has_no_labels_;
  ::google::protobuf::int32 random_access_chunk_size_;
  ::std::string* predicted_boxes_file_;
  ::std::string* file_pattern_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dataset_name_;
  bool can_translate_;
  bool can_flip_;
  bool pixelwise_normalize_;
  ::google::protobuf::int32 gpu_id_;
  ::google::protobuf::int32 max_dataset_size_;
  ::google::protobuf::int32 raw_image_size_;
  ::google::protobuf::int32 stride_;
  float pca_noise_stddev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_convnet_5fconfig_2eproto();
  friend void protobuf_AssignDesc_convnet_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_convnet_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static DatasetConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// Layer

// required string name = 1;
inline bool Layer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Layer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Layer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Layer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Layer::name() const {
  return *name_;
}
inline void Layer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Layer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Layer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Layer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num_channels = 2;
inline bool Layer::has_num_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_num_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_num_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_num_channels() {
  num_channels_ = 0;
  clear_has_num_channels();
}
inline ::google::protobuf::int32 Layer::num_channels() const {
  return num_channels_;
}
inline void Layer::set_num_channels(::google::protobuf::int32 value) {
  set_has_num_channels();
  num_channels_ = value;
}

// optional int32 size = 3 [default = -1];
inline bool Layer::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Layer::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Layer::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Layer::clear_size() {
  size_ = -1;
  clear_has_size();
}
inline ::google::protobuf::int32 Layer::size() const {
  return size_;
}
inline void Layer::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional float dropprob = 4 [default = 0];
inline bool Layer::has_dropprob() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Layer::set_has_dropprob() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Layer::clear_has_dropprob() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Layer::clear_dropprob() {
  dropprob_ = 0;
  clear_has_dropprob();
}
inline float Layer::dropprob() const {
  return dropprob_;
}
inline void Layer::set_dropprob(float value) {
  set_has_dropprob();
  dropprob_ = value;
}

// optional bool is_input = 5 [default = false];
inline bool Layer::has_is_input() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Layer::set_has_is_input() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Layer::clear_has_is_input() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Layer::clear_is_input() {
  is_input_ = false;
  clear_has_is_input();
}
inline bool Layer::is_input() const {
  return is_input_;
}
inline void Layer::set_is_input(bool value) {
  set_has_is_input();
  is_input_ = value;
}

// optional .config.Layer.Activation activation = 6 [default = LINEAR];
inline bool Layer::has_activation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Layer::set_has_activation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Layer::clear_has_activation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Layer::clear_activation() {
  activation_ = 0;
  clear_has_activation();
}
inline ::config::Layer_Activation Layer::activation() const {
  return static_cast< ::config::Layer_Activation >(activation_);
}
inline void Layer::set_activation(::config::Layer_Activation value) {
  assert(::config::Layer_Activation_IsValid(value));
  set_has_activation();
  activation_ = value;
}

// optional bool is_spatial_output = 7 [default = false];
inline bool Layer::has_is_spatial_output() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Layer::set_has_is_spatial_output() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Layer::clear_has_is_spatial_output() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Layer::clear_is_spatial_output() {
  is_spatial_output_ = false;
  clear_has_is_spatial_output();
}
inline bool Layer::is_spatial_output() const {
  return is_spatial_output_;
}
inline void Layer::set_is_spatial_output(bool value) {
  set_has_is_spatial_output();
  is_spatial_output_ = value;
}

// optional bool is_classifier_output = 8 [default = false];
inline bool Layer::has_is_classifier_output() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Layer::set_has_is_classifier_output() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Layer::clear_has_is_classifier_output() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Layer::clear_is_classifier_output() {
  is_classifier_output_ = false;
  clear_has_is_classifier_output();
}
inline bool Layer::is_classifier_output() const {
  return is_classifier_output_;
}
inline void Layer::set_is_classifier_output(bool value) {
  set_has_is_classifier_output();
  is_classifier_output_ = value;
}

// optional bool display = 9 [default = false];
inline bool Layer::has_display() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Layer::set_has_display() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Layer::clear_has_display() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Layer::clear_display() {
  display_ = false;
  clear_has_display();
}
inline bool Layer::display() const {
  return display_;
}
inline void Layer::set_display(bool value) {
  set_has_display();
  display_ = value;
}

// optional bool is_output = 10 [default = false];
inline bool Layer::has_is_output() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Layer::set_has_is_output() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Layer::clear_has_is_output() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Layer::clear_is_output() {
  is_output_ = false;
  clear_has_is_output();
}
inline bool Layer::is_output() const {
  return is_output_;
}
inline void Layer::set_is_output(bool value) {
  set_has_is_output();
  is_output_ = value;
}

// optional bool gaussian_dropout = 11 [default = false];
inline bool Layer::has_gaussian_dropout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Layer::set_has_gaussian_dropout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Layer::clear_has_gaussian_dropout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Layer::clear_gaussian_dropout() {
  gaussian_dropout_ = false;
  clear_has_gaussian_dropout();
}
inline bool Layer::gaussian_dropout() const {
  return gaussian_dropout_;
}
inline void Layer::set_gaussian_dropout(bool value) {
  set_has_gaussian_dropout();
  gaussian_dropout_ = value;
}

// optional float max_act_gaussian_dropout = 12 [default = -1];
inline bool Layer::has_max_act_gaussian_dropout() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Layer::set_has_max_act_gaussian_dropout() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Layer::clear_has_max_act_gaussian_dropout() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Layer::clear_max_act_gaussian_dropout() {
  max_act_gaussian_dropout_ = -1;
  clear_has_max_act_gaussian_dropout();
}
inline float Layer::max_act_gaussian_dropout() const {
  return max_act_gaussian_dropout_;
}
inline void Layer::set_max_act_gaussian_dropout(float value) {
  set_has_max_act_gaussian_dropout();
  max_act_gaussian_dropout_ = value;
}

// optional int32 gpu_id = 13 [default = 0];
inline bool Layer::has_gpu_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Layer::set_has_gpu_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Layer::clear_has_gpu_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Layer::clear_gpu_id() {
  gpu_id_ = 0;
  clear_has_gpu_id();
}
inline ::google::protobuf::int32 Layer::gpu_id() const {
  return gpu_id_;
}
inline void Layer::set_gpu_id(::google::protobuf::int32 value) {
  set_has_gpu_id();
  gpu_id_ = value;
}

// -------------------------------------------------------------------

// Optimizer

// optional .config.Optimizer.OptimizerType optimizer_type = 1 [default = STOCHASTIC_GRADIENT_DESCENT];
inline bool Optimizer::has_optimizer_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Optimizer::set_has_optimizer_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Optimizer::clear_has_optimizer_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Optimizer::clear_optimizer_type() {
  optimizer_type_ = 0;
  clear_has_optimizer_type();
}
inline ::config::Optimizer_OptimizerType Optimizer::optimizer_type() const {
  return static_cast< ::config::Optimizer_OptimizerType >(optimizer_type_);
}
inline void Optimizer::set_optimizer_type(::config::Optimizer_OptimizerType value) {
  assert(::config::Optimizer_OptimizerType_IsValid(value));
  set_has_optimizer_type();
  optimizer_type_ = value;
}

// optional float epsilon = 2 [default = 0];
inline bool Optimizer::has_epsilon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Optimizer::set_has_epsilon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Optimizer::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Optimizer::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline float Optimizer::epsilon() const {
  return epsilon_;
}
inline void Optimizer::set_epsilon(float value) {
  set_has_epsilon();
  epsilon_ = value;
}

// optional int32 epsilon_decay_timescale = 3 [default = 0];
inline bool Optimizer::has_epsilon_decay_timescale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Optimizer::set_has_epsilon_decay_timescale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Optimizer::clear_has_epsilon_decay_timescale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Optimizer::clear_epsilon_decay_timescale() {
  epsilon_decay_timescale_ = 0;
  clear_has_epsilon_decay_timescale();
}
inline ::google::protobuf::int32 Optimizer::epsilon_decay_timescale() const {
  return epsilon_decay_timescale_;
}
inline void Optimizer::set_epsilon_decay_timescale(::google::protobuf::int32 value) {
  set_has_epsilon_decay_timescale();
  epsilon_decay_timescale_ = value;
}

// optional float initial_momentum = 4 [default = 0];
inline bool Optimizer::has_initial_momentum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Optimizer::set_has_initial_momentum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Optimizer::clear_has_initial_momentum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Optimizer::clear_initial_momentum() {
  initial_momentum_ = 0;
  clear_has_initial_momentum();
}
inline float Optimizer::initial_momentum() const {
  return initial_momentum_;
}
inline void Optimizer::set_initial_momentum(float value) {
  set_has_initial_momentum();
  initial_momentum_ = value;
}

// optional float final_momentum = 5 [default = 0];
inline bool Optimizer::has_final_momentum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Optimizer::set_has_final_momentum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Optimizer::clear_has_final_momentum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Optimizer::clear_final_momentum() {
  final_momentum_ = 0;
  clear_has_final_momentum();
}
inline float Optimizer::final_momentum() const {
  return final_momentum_;
}
inline void Optimizer::set_final_momentum(float value) {
  set_has_final_momentum();
  final_momentum_ = value;
}

// optional int32 momentum_transition_timescale = 6 [default = 0];
inline bool Optimizer::has_momentum_transition_timescale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Optimizer::set_has_momentum_transition_timescale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Optimizer::clear_has_momentum_transition_timescale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Optimizer::clear_momentum_transition_timescale() {
  momentum_transition_timescale_ = 0;
  clear_has_momentum_transition_timescale();
}
inline ::google::protobuf::int32 Optimizer::momentum_transition_timescale() const {
  return momentum_transition_timescale_;
}
inline void Optimizer::set_momentum_transition_timescale(::google::protobuf::int32 value) {
  set_has_momentum_transition_timescale();
  momentum_transition_timescale_ = value;
}

// optional float l2_decay = 7 [default = 0];
inline bool Optimizer::has_l2_decay() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Optimizer::set_has_l2_decay() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Optimizer::clear_has_l2_decay() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Optimizer::clear_l2_decay() {
  l2_decay_ = 0;
  clear_has_l2_decay();
}
inline float Optimizer::l2_decay() const {
  return l2_decay_;
}
inline void Optimizer::set_l2_decay(float value) {
  set_has_l2_decay();
  l2_decay_ = value;
}

// optional float weight_norm_limit = 8 [default = 0];
inline bool Optimizer::has_weight_norm_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Optimizer::set_has_weight_norm_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Optimizer::clear_has_weight_norm_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Optimizer::clear_weight_norm_limit() {
  weight_norm_limit_ = 0;
  clear_has_weight_norm_limit();
}
inline float Optimizer::weight_norm_limit() const {
  return weight_norm_limit_;
}
inline void Optimizer::set_weight_norm_limit(float value) {
  set_has_weight_norm_limit();
  weight_norm_limit_ = value;
}

// optional float weight_norm_constraint = 9 [default = 0];
inline bool Optimizer::has_weight_norm_constraint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Optimizer::set_has_weight_norm_constraint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Optimizer::clear_has_weight_norm_constraint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Optimizer::clear_weight_norm_constraint() {
  weight_norm_constraint_ = 0;
  clear_has_weight_norm_constraint();
}
inline float Optimizer::weight_norm_constraint() const {
  return weight_norm_constraint_;
}
inline void Optimizer::set_weight_norm_constraint(float value) {
  set_has_weight_norm_constraint();
  weight_norm_constraint_ = value;
}

// optional .config.Optimizer.Decay epsilon_decay = 10 [default = NONE];
inline bool Optimizer::has_epsilon_decay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Optimizer::set_has_epsilon_decay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Optimizer::clear_has_epsilon_decay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Optimizer::clear_epsilon_decay() {
  epsilon_decay_ = 0;
  clear_has_epsilon_decay();
}
inline ::config::Optimizer_Decay Optimizer::epsilon_decay() const {
  return static_cast< ::config::Optimizer_Decay >(epsilon_decay_);
}
inline void Optimizer::set_epsilon_decay(::config::Optimizer_Decay value) {
  assert(::config::Optimizer_Decay_IsValid(value));
  set_has_epsilon_decay();
  epsilon_decay_ = value;
}

// optional float minimum_epsilon = 11 [default = 0];
inline bool Optimizer::has_minimum_epsilon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Optimizer::set_has_minimum_epsilon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Optimizer::clear_has_minimum_epsilon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Optimizer::clear_minimum_epsilon() {
  minimum_epsilon_ = 0;
  clear_has_minimum_epsilon();
}
inline float Optimizer::minimum_epsilon() const {
  return minimum_epsilon_;
}
inline void Optimizer::set_minimum_epsilon(float value) {
  set_has_minimum_epsilon();
  minimum_epsilon_ = value;
}

// optional float gradient_clip = 12 [default = -1];
inline bool Optimizer::has_gradient_clip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Optimizer::set_has_gradient_clip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Optimizer::clear_has_gradient_clip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Optimizer::clear_gradient_clip() {
  gradient_clip_ = -1;
  clear_has_gradient_clip();
}
inline float Optimizer::gradient_clip() const {
  return gradient_clip_;
}
inline void Optimizer::set_gradient_clip(float value) {
  set_has_gradient_clip();
  gradient_clip_ = value;
}

// optional int32 lbfgs_memory = 13 [default = 0];
inline bool Optimizer::has_lbfgs_memory() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Optimizer::set_has_lbfgs_memory() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Optimizer::clear_has_lbfgs_memory() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Optimizer::clear_lbfgs_memory() {
  lbfgs_memory_ = 0;
  clear_has_lbfgs_memory();
}
inline ::google::protobuf::int32 Optimizer::lbfgs_memory() const {
  return lbfgs_memory_;
}
inline void Optimizer::set_lbfgs_memory(::google::protobuf::int32 value) {
  set_has_lbfgs_memory();
  lbfgs_memory_ = value;
}

// -------------------------------------------------------------------

// Edge

// required string source = 1;
inline bool Edge::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& Edge::source() const {
  return *source_;
}
inline void Edge::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void Edge::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void Edge::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* Edge::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Edge::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dest = 2;
inline bool Edge::has_dest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_dest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_dest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_dest() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& Edge::dest() const {
  return *dest_;
}
inline void Edge::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Edge::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Edge::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  return dest_;
}
inline ::std::string* Edge::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Edge::set_allocated_dest(::std::string* dest) {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_;
  }
  if (dest) {
    set_has_dest();
    dest_ = dest;
  } else {
    clear_has_dest();
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .config.Edge.EdgeType edge_type = 3 [default = FC];
inline bool Edge::has_edge_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_edge_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_edge_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_edge_type() {
  edge_type_ = 0;
  clear_has_edge_type();
}
inline ::config::Edge_EdgeType Edge::edge_type() const {
  return static_cast< ::config::Edge_EdgeType >(edge_type_);
}
inline void Edge::set_edge_type(::config::Edge_EdgeType value) {
  assert(::config::Edge_EdgeType_IsValid(value));
  set_has_edge_type();
  edge_type_ = value;
}

// optional int32 kernel_size = 4 [default = 1];
inline bool Edge::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Edge::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Edge::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Edge::clear_kernel_size() {
  kernel_size_ = 1;
  clear_has_kernel_size();
}
inline ::google::protobuf::int32 Edge::kernel_size() const {
  return kernel_size_;
}
inline void Edge::set_kernel_size(::google::protobuf::int32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional int32 stride = 5 [default = 1];
inline bool Edge::has_stride() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Edge::set_has_stride() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Edge::clear_has_stride() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Edge::clear_stride() {
  stride_ = 1;
  clear_has_stride();
}
inline ::google::protobuf::int32 Edge::stride() const {
  return stride_;
}
inline void Edge::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// optional int32 padding = 6 [default = 0];
inline bool Edge::has_padding() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Edge::set_has_padding() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Edge::clear_has_padding() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Edge::clear_padding() {
  padding_ = 0;
  clear_has_padding();
}
inline ::google::protobuf::int32 Edge::padding() const {
  return padding_;
}
inline void Edge::set_padding(::google::protobuf::int32 value) {
  set_has_padding();
  padding_ = value;
}

// optional .config.Edge.Initialization initialization = 7 [default = DENSE_GAUSSIAN_SQRT_FAN_IN];
inline bool Edge::has_initialization() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Edge::set_has_initialization() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Edge::clear_has_initialization() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Edge::clear_initialization() {
  initialization_ = 3;
  clear_has_initialization();
}
inline ::config::Edge_Initialization Edge::initialization() const {
  return static_cast< ::config::Edge_Initialization >(initialization_);
}
inline void Edge::set_initialization(::config::Edge_Initialization value) {
  assert(::config::Edge_Initialization_IsValid(value));
  set_has_initialization();
  initialization_ = value;
}

// optional float init_wt = 8 [default = 1];
inline bool Edge::has_init_wt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Edge::set_has_init_wt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Edge::clear_has_init_wt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Edge::clear_init_wt() {
  init_wt_ = 1;
  clear_has_init_wt();
}
inline float Edge::init_wt() const {
  return init_wt_;
}
inline void Edge::set_init_wt(float value) {
  set_has_init_wt();
  init_wt_ = value;
}

// optional float init_bias = 9 [default = 0];
inline bool Edge::has_init_bias() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Edge::set_has_init_bias() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Edge::clear_has_init_bias() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Edge::clear_init_bias() {
  init_bias_ = 0;
  clear_has_init_bias();
}
inline float Edge::init_bias() const {
  return init_bias_;
}
inline void Edge::set_init_bias(float value) {
  set_has_init_bias();
  init_bias_ = value;
}

// optional .config.Optimizer weight_optimizer = 10;
inline bool Edge::has_weight_optimizer() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Edge::set_has_weight_optimizer() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Edge::clear_has_weight_optimizer() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Edge::clear_weight_optimizer() {
  if (weight_optimizer_ != NULL) weight_optimizer_->::config::Optimizer::Clear();
  clear_has_weight_optimizer();
}
inline const ::config::Optimizer& Edge::weight_optimizer() const {
  return weight_optimizer_ != NULL ? *weight_optimizer_ : *default_instance_->weight_optimizer_;
}
inline ::config::Optimizer* Edge::mutable_weight_optimizer() {
  set_has_weight_optimizer();
  if (weight_optimizer_ == NULL) weight_optimizer_ = new ::config::Optimizer;
  return weight_optimizer_;
}
inline ::config::Optimizer* Edge::release_weight_optimizer() {
  clear_has_weight_optimizer();
  ::config::Optimizer* temp = weight_optimizer_;
  weight_optimizer_ = NULL;
  return temp;
}
inline void Edge::set_allocated_weight_optimizer(::config::Optimizer* weight_optimizer) {
  delete weight_optimizer_;
  weight_optimizer_ = weight_optimizer;
  if (weight_optimizer) {
    set_has_weight_optimizer();
  } else {
    clear_has_weight_optimizer();
  }
}

// optional .config.Optimizer bias_optimizer = 11;
inline bool Edge::has_bias_optimizer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Edge::set_has_bias_optimizer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Edge::clear_has_bias_optimizer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Edge::clear_bias_optimizer() {
  if (bias_optimizer_ != NULL) bias_optimizer_->::config::Optimizer::Clear();
  clear_has_bias_optimizer();
}
inline const ::config::Optimizer& Edge::bias_optimizer() const {
  return bias_optimizer_ != NULL ? *bias_optimizer_ : *default_instance_->bias_optimizer_;
}
inline ::config::Optimizer* Edge::mutable_bias_optimizer() {
  set_has_bias_optimizer();
  if (bias_optimizer_ == NULL) bias_optimizer_ = new ::config::Optimizer;
  return bias_optimizer_;
}
inline ::config::Optimizer* Edge::release_bias_optimizer() {
  clear_has_bias_optimizer();
  ::config::Optimizer* temp = bias_optimizer_;
  bias_optimizer_ = NULL;
  return temp;
}
inline void Edge::set_allocated_bias_optimizer(::config::Optimizer* bias_optimizer) {
  delete bias_optimizer_;
  bias_optimizer_ = bias_optimizer;
  if (bias_optimizer) {
    set_has_bias_optimizer();
  } else {
    clear_has_bias_optimizer();
  }
}

// optional bool shared_bias = 12 [default = false];
inline bool Edge::has_shared_bias() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Edge::set_has_shared_bias() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Edge::clear_has_shared_bias() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Edge::clear_shared_bias() {
  shared_bias_ = false;
  clear_has_shared_bias();
}
inline bool Edge::shared_bias() const {
  return shared_bias_;
}
inline void Edge::set_shared_bias(bool value) {
  set_has_shared_bias();
  shared_bias_ = value;
}

// optional bool block_backprop = 13 [default = false];
inline bool Edge::has_block_backprop() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Edge::set_has_block_backprop() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Edge::clear_has_block_backprop() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Edge::clear_block_backprop() {
  block_backprop_ = false;
  clear_has_block_backprop();
}
inline bool Edge::block_backprop() const {
  return block_backprop_;
}
inline void Edge::set_block_backprop(bool value) {
  set_has_block_backprop();
  block_backprop_ = value;
}

// optional string tied_to = 14;
inline bool Edge::has_tied_to() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Edge::set_has_tied_to() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Edge::clear_has_tied_to() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Edge::clear_tied_to() {
  if (tied_to_ != &::google::protobuf::internal::kEmptyString) {
    tied_to_->clear();
  }
  clear_has_tied_to();
}
inline const ::std::string& Edge::tied_to() const {
  return *tied_to_;
}
inline void Edge::set_tied_to(const ::std::string& value) {
  set_has_tied_to();
  if (tied_to_ == &::google::protobuf::internal::kEmptyString) {
    tied_to_ = new ::std::string;
  }
  tied_to_->assign(value);
}
inline void Edge::set_tied_to(const char* value) {
  set_has_tied_to();
  if (tied_to_ == &::google::protobuf::internal::kEmptyString) {
    tied_to_ = new ::std::string;
  }
  tied_to_->assign(value);
}
inline void Edge::set_tied_to(const char* value, size_t size) {
  set_has_tied_to();
  if (tied_to_ == &::google::protobuf::internal::kEmptyString) {
    tied_to_ = new ::std::string;
  }
  tied_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge::mutable_tied_to() {
  set_has_tied_to();
  if (tied_to_ == &::google::protobuf::internal::kEmptyString) {
    tied_to_ = new ::std::string;
  }
  return tied_to_;
}
inline ::std::string* Edge::release_tied_to() {
  clear_has_tied_to();
  if (tied_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tied_to_;
    tied_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Edge::set_allocated_tied_to(::std::string* tied_to) {
  if (tied_to_ != &::google::protobuf::internal::kEmptyString) {
    delete tied_to_;
  }
  if (tied_to) {
    set_has_tied_to();
    tied_to_ = tied_to;
  } else {
    clear_has_tied_to();
    tied_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool has_no_bias = 15 [default = false];
inline bool Edge::has_has_no_bias() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Edge::set_has_has_no_bias() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Edge::clear_has_has_no_bias() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Edge::clear_has_no_bias() {
  has_no_bias_ = false;
  clear_has_has_no_bias();
}
inline bool Edge::has_no_bias() const {
  return has_no_bias_;
}
inline void Edge::set_has_no_bias(bool value) {
  set_has_has_no_bias();
  has_no_bias_ = value;
}

// optional float scale_gradients = 16 [default = 1];
inline bool Edge::has_scale_gradients() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Edge::set_has_scale_gradients() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Edge::clear_has_scale_gradients() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Edge::clear_scale_gradients() {
  scale_gradients_ = 1;
  clear_has_scale_gradients();
}
inline float Edge::scale_gradients() const {
  return scale_gradients_;
}
inline void Edge::set_scale_gradients(float value) {
  set_has_scale_gradients();
  scale_gradients_ = value;
}

// optional int32 partial_sum = 17 [default = 0];
inline bool Edge::has_partial_sum() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Edge::set_has_partial_sum() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Edge::clear_has_partial_sum() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Edge::clear_partial_sum() {
  partial_sum_ = 0;
  clear_has_partial_sum();
}
inline ::google::protobuf::int32 Edge::partial_sum() const {
  return partial_sum_;
}
inline void Edge::set_partial_sum(::google::protobuf::int32 value) {
  set_has_partial_sum();
  partial_sum_ = value;
}

// optional int32 sample_factor = 18 [default = 1];
inline bool Edge::has_sample_factor() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Edge::set_has_sample_factor() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Edge::clear_has_sample_factor() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Edge::clear_sample_factor() {
  sample_factor_ = 1;
  clear_has_sample_factor();
}
inline ::google::protobuf::int32 Edge::sample_factor() const {
  return sample_factor_;
}
inline void Edge::set_sample_factor(::google::protobuf::int32 value) {
  set_has_sample_factor();
  sample_factor_ = value;
}

// optional bool response_norm_in_blocks = 19 [default = false];
inline bool Edge::has_response_norm_in_blocks() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Edge::set_has_response_norm_in_blocks() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Edge::clear_has_response_norm_in_blocks() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Edge::clear_response_norm_in_blocks() {
  response_norm_in_blocks_ = false;
  clear_has_response_norm_in_blocks();
}
inline bool Edge::response_norm_in_blocks() const {
  return response_norm_in_blocks_;
}
inline void Edge::set_response_norm_in_blocks(bool value) {
  set_has_response_norm_in_blocks();
  response_norm_in_blocks_ = value;
}

// optional float add_scale = 20 [default = 0];
inline bool Edge::has_add_scale() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Edge::set_has_add_scale() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Edge::clear_has_add_scale() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Edge::clear_add_scale() {
  add_scale_ = 0;
  clear_has_add_scale();
}
inline float Edge::add_scale() const {
  return add_scale_;
}
inline void Edge::set_add_scale(float value) {
  set_has_add_scale();
  add_scale_ = value;
}

// optional float pow_scale = 21 [default = 0];
inline bool Edge::has_pow_scale() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Edge::set_has_pow_scale() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Edge::clear_has_pow_scale() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Edge::clear_pow_scale() {
  pow_scale_ = 0;
  clear_has_pow_scale();
}
inline float Edge::pow_scale() const {
  return pow_scale_;
}
inline void Edge::set_pow_scale(float value) {
  set_has_pow_scale();
  pow_scale_ = value;
}

// optional float frac_of_filters_response_norm = 22 [default = 0];
inline bool Edge::has_frac_of_filters_response_norm() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Edge::set_has_frac_of_filters_response_norm() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Edge::clear_has_frac_of_filters_response_norm() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Edge::clear_frac_of_filters_response_norm() {
  frac_of_filters_response_norm_ = 0;
  clear_has_frac_of_filters_response_norm();
}
inline float Edge::frac_of_filters_response_norm() const {
  return frac_of_filters_response_norm_;
}
inline void Edge::set_frac_of_filters_response_norm(float value) {
  set_has_frac_of_filters_response_norm();
  frac_of_filters_response_norm_ = value;
}

// optional int32 polyak_queue_size = 23 [default = 0];
inline bool Edge::has_polyak_queue_size() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Edge::set_has_polyak_queue_size() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Edge::clear_has_polyak_queue_size() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Edge::clear_polyak_queue_size() {
  polyak_queue_size_ = 0;
  clear_has_polyak_queue_size();
}
inline ::google::protobuf::int32 Edge::polyak_queue_size() const {
  return polyak_queue_size_;
}
inline void Edge::set_polyak_queue_size(::google::protobuf::int32 value) {
  set_has_polyak_queue_size();
  polyak_queue_size_ = value;
}

// optional int32 gpu_id = 24 [default = 0];
inline bool Edge::has_gpu_id() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Edge::set_has_gpu_id() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Edge::clear_has_gpu_id() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Edge::clear_gpu_id() {
  gpu_id_ = 0;
  clear_has_gpu_id();
}
inline ::google::protobuf::int32 Edge::gpu_id() const {
  return gpu_id_;
}
inline void Edge::set_gpu_id(::google::protobuf::int32 value) {
  set_has_gpu_id();
  gpu_id_ = value;
}

// -------------------------------------------------------------------

// Model

// required string name = 1;
inline bool Model::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Model::name() const {
  return *name_;
}
inline void Model::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Model::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Model::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Model::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .config.Layer layer = 2;
inline int Model::layer_size() const {
  return layer_.size();
}
inline void Model::clear_layer() {
  layer_.Clear();
}
inline const ::config::Layer& Model::layer(int index) const {
  return layer_.Get(index);
}
inline ::config::Layer* Model::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::config::Layer* Model::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::config::Layer >&
Model::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::config::Layer >*
Model::mutable_layer() {
  return &layer_;
}

// repeated .config.Edge edge = 3;
inline int Model::edge_size() const {
  return edge_.size();
}
inline void Model::clear_edge() {
  edge_.Clear();
}
inline const ::config::Edge& Model::edge(int index) const {
  return edge_.Get(index);
}
inline ::config::Edge* Model::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::config::Edge* Model::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::config::Edge >&
Model::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::config::Edge >*
Model::mutable_edge() {
  return &edge_;
}

// required int32 seed = 4;
inline bool Model::has_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Model::set_has_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Model::clear_has_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Model::clear_seed() {
  seed_ = 0;
  clear_has_seed();
}
inline ::google::protobuf::int32 Model::seed() const {
  return seed_;
}
inline void Model::set_seed(::google::protobuf::int32 value) {
  set_has_seed();
  seed_ = value;
}

// optional int32 max_iter = 5 [default = -1];
inline bool Model::has_max_iter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Model::set_has_max_iter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Model::clear_has_max_iter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Model::clear_max_iter() {
  max_iter_ = -1;
  clear_has_max_iter();
}
inline ::google::protobuf::int32 Model::max_iter() const {
  return max_iter_;
}
inline void Model::set_max_iter(::google::protobuf::int32 value) {
  set_has_max_iter();
  max_iter_ = value;
}

// optional int32 display_after = 6 [default = -1];
inline bool Model::has_display_after() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Model::set_has_display_after() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Model::clear_has_display_after() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Model::clear_display_after() {
  display_after_ = -1;
  clear_has_display_after();
}
inline ::google::protobuf::int32 Model::display_after() const {
  return display_after_;
}
inline void Model::set_display_after(::google::protobuf::int32 value) {
  set_has_display_after();
  display_after_ = value;
}

// optional int32 save_after = 7 [default = -1];
inline bool Model::has_save_after() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Model::set_has_save_after() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Model::clear_has_save_after() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Model::clear_save_after() {
  save_after_ = -1;
  clear_has_save_after();
}
inline ::google::protobuf::int32 Model::save_after() const {
  return save_after_;
}
inline void Model::set_save_after(::google::protobuf::int32 value) {
  set_has_save_after();
  save_after_ = value;
}

// optional int32 image_size = 8 [default = 0];
inline bool Model::has_image_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Model::set_has_image_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Model::clear_has_image_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Model::clear_image_size() {
  image_size_ = 0;
  clear_has_image_size();
}
inline ::google::protobuf::int32 Model::image_size() const {
  return image_size_;
}
inline void Model::set_image_size(::google::protobuf::int32 value) {
  set_has_image_size();
  image_size_ = value;
}

// optional int32 patch_size = 9 [default = 0];
inline bool Model::has_patch_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Model::set_has_patch_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Model::clear_has_patch_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Model::clear_patch_size() {
  patch_size_ = 0;
  clear_has_patch_size();
}
inline ::google::protobuf::int32 Model::patch_size() const {
  return patch_size_;
}
inline void Model::set_patch_size(::google::protobuf::int32 value) {
  set_has_patch_size();
  patch_size_ = value;
}

// optional int32 print_after = 10 [default = -1];
inline bool Model::has_print_after() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Model::set_has_print_after() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Model::clear_has_print_after() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Model::clear_print_after() {
  print_after_ = -1;
  clear_has_print_after();
}
inline ::google::protobuf::int32 Model::print_after() const {
  return print_after_;
}
inline void Model::set_print_after(::google::protobuf::int32 value) {
  set_has_print_after();
  print_after_ = value;
}

// optional int32 current_iter = 11 [default = 0];
inline bool Model::has_current_iter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Model::set_has_current_iter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Model::clear_has_current_iter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Model::clear_current_iter() {
  current_iter_ = 0;
  clear_has_current_iter();
}
inline ::google::protobuf::int32 Model::current_iter() const {
  return current_iter_;
}
inline void Model::set_current_iter(::google::protobuf::int32 value) {
  set_has_current_iter();
  current_iter_ = value;
}

// optional string checkpoint_dir = 12;
inline bool Model::has_checkpoint_dir() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Model::set_has_checkpoint_dir() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Model::clear_has_checkpoint_dir() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Model::clear_checkpoint_dir() {
  if (checkpoint_dir_ != &::google::protobuf::internal::kEmptyString) {
    checkpoint_dir_->clear();
  }
  clear_has_checkpoint_dir();
}
inline const ::std::string& Model::checkpoint_dir() const {
  return *checkpoint_dir_;
}
inline void Model::set_checkpoint_dir(const ::std::string& value) {
  set_has_checkpoint_dir();
  if (checkpoint_dir_ == &::google::protobuf::internal::kEmptyString) {
    checkpoint_dir_ = new ::std::string;
  }
  checkpoint_dir_->assign(value);
}
inline void Model::set_checkpoint_dir(const char* value) {
  set_has_checkpoint_dir();
  if (checkpoint_dir_ == &::google::protobuf::internal::kEmptyString) {
    checkpoint_dir_ = new ::std::string;
  }
  checkpoint_dir_->assign(value);
}
inline void Model::set_checkpoint_dir(const char* value, size_t size) {
  set_has_checkpoint_dir();
  if (checkpoint_dir_ == &::google::protobuf::internal::kEmptyString) {
    checkpoint_dir_ = new ::std::string;
  }
  checkpoint_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_checkpoint_dir() {
  set_has_checkpoint_dir();
  if (checkpoint_dir_ == &::google::protobuf::internal::kEmptyString) {
    checkpoint_dir_ = new ::std::string;
  }
  return checkpoint_dir_;
}
inline ::std::string* Model::release_checkpoint_dir() {
  clear_has_checkpoint_dir();
  if (checkpoint_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checkpoint_dir_;
    checkpoint_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_checkpoint_dir(::std::string* checkpoint_dir) {
  if (checkpoint_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete checkpoint_dir_;
  }
  if (checkpoint_dir) {
    set_has_checkpoint_dir();
    checkpoint_dir_ = checkpoint_dir;
  } else {
    clear_has_checkpoint_dir();
    checkpoint_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool has_spatial_outputs = 13 [default = false];
inline bool Model::has_has_spatial_outputs() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Model::set_has_has_spatial_outputs() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Model::clear_has_has_spatial_outputs() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Model::clear_has_spatial_outputs() {
  has_spatial_outputs_ = false;
  clear_has_has_spatial_outputs();
}
inline bool Model::has_spatial_outputs() const {
  return has_spatial_outputs_;
}
inline void Model::set_has_spatial_outputs(bool value) {
  set_has_has_spatial_outputs();
  has_spatial_outputs_ = value;
}

// optional bool display_spatial_output = 14 [default = false];
inline bool Model::has_display_spatial_output() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Model::set_has_display_spatial_output() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Model::clear_has_display_spatial_output() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Model::clear_display_spatial_output() {
  display_spatial_output_ = false;
  clear_has_display_spatial_output();
}
inline bool Model::display_spatial_output() const {
  return display_spatial_output_;
}
inline void Model::set_display_spatial_output(bool value) {
  set_has_display_spatial_output();
  display_spatial_output_ = value;
}

// repeated string timestamp = 15;
inline int Model::timestamp_size() const {
  return timestamp_.size();
}
inline void Model::clear_timestamp() {
  timestamp_.Clear();
}
inline const ::std::string& Model::timestamp(int index) const {
  return timestamp_.Get(index);
}
inline ::std::string* Model::mutable_timestamp(int index) {
  return timestamp_.Mutable(index);
}
inline void Model::set_timestamp(int index, const ::std::string& value) {
  timestamp_.Mutable(index)->assign(value);
}
inline void Model::set_timestamp(int index, const char* value) {
  timestamp_.Mutable(index)->assign(value);
}
inline void Model::set_timestamp(int index, const char* value, size_t size) {
  timestamp_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::add_timestamp() {
  return timestamp_.Add();
}
inline void Model::add_timestamp(const ::std::string& value) {
  timestamp_.Add()->assign(value);
}
inline void Model::add_timestamp(const char* value) {
  timestamp_.Add()->assign(value);
}
inline void Model::add_timestamp(const char* value, size_t size) {
  timestamp_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Model::timestamp() const {
  return timestamp_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Model::mutable_timestamp() {
  return &timestamp_;
}

// optional bool det_classifier = 16 [default = false];
inline bool Model::has_det_classifier() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Model::set_has_det_classifier() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Model::clear_has_det_classifier() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Model::clear_det_classifier() {
  det_classifier_ = false;
  clear_has_det_classifier();
}
inline bool Model::det_classifier() const {
  return det_classifier_;
}
inline void Model::set_det_classifier(bool value) {
  set_has_det_classifier();
  det_classifier_ = value;
}

// optional bool display = 17 [default = false];
inline bool Model::has_display() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Model::set_has_display() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Model::clear_has_display() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Model::clear_display() {
  display_ = false;
  clear_has_display();
}
inline bool Model::display() const {
  return display_;
}
inline void Model::set_display(bool value) {
  set_has_display();
  display_ = value;
}

// optional int32 validate_after = 18 [default = -1];
inline bool Model::has_validate_after() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Model::set_has_validate_after() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Model::clear_has_validate_after() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Model::clear_validate_after() {
  validate_after_ = -1;
  clear_has_validate_after();
}
inline ::google::protobuf::int32 Model::validate_after() const {
  return validate_after_;
}
inline void Model::set_validate_after(::google::protobuf::int32 value) {
  set_has_validate_after();
  validate_after_ = value;
}

// optional float reduce_lr_factor = 19 [default = 1];
inline bool Model::has_reduce_lr_factor() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Model::set_has_reduce_lr_factor() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Model::clear_has_reduce_lr_factor() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Model::clear_reduce_lr_factor() {
  reduce_lr_factor_ = 1;
  clear_has_reduce_lr_factor();
}
inline float Model::reduce_lr_factor() const {
  return reduce_lr_factor_;
}
inline void Model::set_reduce_lr_factor(float value) {
  set_has_reduce_lr_factor();
  reduce_lr_factor_ = value;
}

// optional float reduce_lr_threshold = 20 [default = 0];
inline bool Model::has_reduce_lr_threshold() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Model::set_has_reduce_lr_threshold() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Model::clear_has_reduce_lr_threshold() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Model::clear_reduce_lr_threshold() {
  reduce_lr_threshold_ = 0;
  clear_has_reduce_lr_threshold();
}
inline float Model::reduce_lr_threshold() const {
  return reduce_lr_threshold_;
}
inline void Model::set_reduce_lr_threshold(float value) {
  set_has_reduce_lr_threshold();
  reduce_lr_threshold_ = value;
}

// optional int32 reduce_lr_num_steps = 21 [default = 0];
inline bool Model::has_reduce_lr_num_steps() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Model::set_has_reduce_lr_num_steps() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Model::clear_has_reduce_lr_num_steps() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Model::clear_reduce_lr_num_steps() {
  reduce_lr_num_steps_ = 0;
  clear_has_reduce_lr_num_steps();
}
inline ::google::protobuf::int32 Model::reduce_lr_num_steps() const {
  return reduce_lr_num_steps_;
}
inline void Model::set_reduce_lr_num_steps(::google::protobuf::int32 value) {
  set_has_reduce_lr_num_steps();
  reduce_lr_num_steps_ = value;
}

// optional int32 reduce_lr_max = 22 [default = 0];
inline bool Model::has_reduce_lr_max() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Model::set_has_reduce_lr_max() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Model::clear_has_reduce_lr_max() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Model::clear_reduce_lr_max() {
  reduce_lr_max_ = 0;
  clear_has_reduce_lr_max();
}
inline ::google::protobuf::int32 Model::reduce_lr_max() const {
  return reduce_lr_max_;
}
inline void Model::set_reduce_lr_max(::google::protobuf::int32 value) {
  set_has_reduce_lr_max();
  reduce_lr_max_ = value;
}

// optional bool smaller_is_better = 23 [default = false];
inline bool Model::has_smaller_is_better() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Model::set_has_smaller_is_better() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Model::clear_has_smaller_is_better() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Model::clear_smaller_is_better() {
  smaller_is_better_ = false;
  clear_has_smaller_is_better();
}
inline bool Model::smaller_is_better() const {
  return smaller_is_better_;
}
inline void Model::set_smaller_is_better(bool value) {
  set_has_smaller_is_better();
  smaller_is_better_ = value;
}

// optional int32 polyak_after = 24 [default = 0];
inline bool Model::has_polyak_after() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Model::set_has_polyak_after() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Model::clear_has_polyak_after() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Model::clear_polyak_after() {
  polyak_after_ = 0;
  clear_has_polyak_after();
}
inline ::google::protobuf::int32 Model::polyak_after() const {
  return polyak_after_;
}
inline void Model::set_polyak_after(::google::protobuf::int32 value) {
  set_has_polyak_after();
  polyak_after_ = value;
}

// optional int32 polyak_queue_size = 25 [default = 0];
inline bool Model::has_polyak_queue_size() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Model::set_has_polyak_queue_size() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Model::clear_has_polyak_queue_size() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Model::clear_polyak_queue_size() {
  polyak_queue_size_ = 0;
  clear_has_polyak_queue_size();
}
inline ::google::protobuf::int32 Model::polyak_queue_size() const {
  return polyak_queue_size_;
}
inline void Model::set_polyak_queue_size(::google::protobuf::int32 value) {
  set_has_polyak_queue_size();
  polyak_queue_size_ = value;
}

// -------------------------------------------------------------------

// DatasetConfig

// required string data_dir = 1;
inline bool DatasetConfig::has_data_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatasetConfig::set_has_data_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatasetConfig::clear_has_data_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatasetConfig::clear_data_dir() {
  if (data_dir_ != &::google::protobuf::internal::kEmptyString) {
    data_dir_->clear();
  }
  clear_has_data_dir();
}
inline const ::std::string& DatasetConfig::data_dir() const {
  return *data_dir_;
}
inline void DatasetConfig::set_data_dir(const ::std::string& value) {
  set_has_data_dir();
  if (data_dir_ == &::google::protobuf::internal::kEmptyString) {
    data_dir_ = new ::std::string;
  }
  data_dir_->assign(value);
}
inline void DatasetConfig::set_data_dir(const char* value) {
  set_has_data_dir();
  if (data_dir_ == &::google::protobuf::internal::kEmptyString) {
    data_dir_ = new ::std::string;
  }
  data_dir_->assign(value);
}
inline void DatasetConfig::set_data_dir(const char* value, size_t size) {
  set_has_data_dir();
  if (data_dir_ == &::google::protobuf::internal::kEmptyString) {
    data_dir_ = new ::std::string;
  }
  data_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetConfig::mutable_data_dir() {
  set_has_data_dir();
  if (data_dir_ == &::google::protobuf::internal::kEmptyString) {
    data_dir_ = new ::std::string;
  }
  return data_dir_;
}
inline ::std::string* DatasetConfig::release_data_dir() {
  clear_has_data_dir();
  if (data_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_dir_;
    data_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DatasetConfig::set_allocated_data_dir(::std::string* data_dir) {
  if (data_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete data_dir_;
  }
  if (data_dir) {
    set_has_data_dir();
    data_dir_ = data_dir;
  } else {
    clear_has_data_dir();
    data_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .config.DatasetConfig.DatasetType dataset_type = 2;
inline bool DatasetConfig::has_dataset_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatasetConfig::set_has_dataset_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatasetConfig::clear_has_dataset_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatasetConfig::clear_dataset_type() {
  dataset_type_ = 0;
  clear_has_dataset_type();
}
inline ::config::DatasetConfig_DatasetType DatasetConfig::dataset_type() const {
  return static_cast< ::config::DatasetConfig_DatasetType >(dataset_type_);
}
inline void DatasetConfig::set_dataset_type(::config::DatasetConfig_DatasetType value) {
  assert(::config::DatasetConfig_DatasetType_IsValid(value));
  set_has_dataset_type();
  dataset_type_ = value;
}

// optional int32 batch_size = 3 [default = 1];
inline bool DatasetConfig::has_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatasetConfig::set_has_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatasetConfig::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatasetConfig::clear_batch_size() {
  batch_size_ = 1;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 DatasetConfig::batch_size() const {
  return batch_size_;
}
inline void DatasetConfig::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional int32 chunk_size = 4 [default = 1];
inline bool DatasetConfig::has_chunk_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatasetConfig::set_has_chunk_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatasetConfig::clear_has_chunk_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatasetConfig::clear_chunk_size() {
  chunk_size_ = 1;
  clear_has_chunk_size();
}
inline ::google::protobuf::int32 DatasetConfig::chunk_size() const {
  return chunk_size_;
}
inline void DatasetConfig::set_chunk_size(::google::protobuf::int32 value) {
  set_has_chunk_size();
  chunk_size_ = value;
}

// repeated int32 labels = 5;
inline int DatasetConfig::labels_size() const {
  return labels_.size();
}
inline void DatasetConfig::clear_labels() {
  labels_.Clear();
}
inline ::google::protobuf::int32 DatasetConfig::labels(int index) const {
  return labels_.Get(index);
}
inline void DatasetConfig::set_labels(int index, ::google::protobuf::int32 value) {
  labels_.Set(index, value);
}
inline void DatasetConfig::add_labels(::google::protobuf::int32 value) {
  labels_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DatasetConfig::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DatasetConfig::mutable_labels() {
  return &labels_;
}

// optional int32 max_reuse_count = 6 [default = 0];
inline bool DatasetConfig::has_max_reuse_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DatasetConfig::set_has_max_reuse_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DatasetConfig::clear_has_max_reuse_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DatasetConfig::clear_max_reuse_count() {
  max_reuse_count_ = 0;
  clear_has_max_reuse_count();
}
inline ::google::protobuf::int32 DatasetConfig::max_reuse_count() const {
  return max_reuse_count_;
}
inline void DatasetConfig::set_max_reuse_count(::google::protobuf::int32 value) {
  set_has_max_reuse_count();
  max_reuse_count_ = value;
}

// optional bool pipeline_loads = 7 [default = false];
inline bool DatasetConfig::has_pipeline_loads() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DatasetConfig::set_has_pipeline_loads() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DatasetConfig::clear_has_pipeline_loads() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DatasetConfig::clear_pipeline_loads() {
  pipeline_loads_ = false;
  clear_has_pipeline_loads();
}
inline bool DatasetConfig::pipeline_loads() const {
  return pipeline_loads_;
}
inline void DatasetConfig::set_pipeline_loads(bool value) {
  set_has_pipeline_loads();
  pipeline_loads_ = value;
}

// optional bool randomize_cpu = 8 [default = false];
inline bool DatasetConfig::has_randomize_cpu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DatasetConfig::set_has_randomize_cpu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DatasetConfig::clear_has_randomize_cpu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DatasetConfig::clear_randomize_cpu() {
  randomize_cpu_ = false;
  clear_has_randomize_cpu();
}
inline bool DatasetConfig::randomize_cpu() const {
  return randomize_cpu_;
}
inline void DatasetConfig::set_randomize_cpu(bool value) {
  set_has_randomize_cpu();
  randomize_cpu_ = value;
}

// optional string mean_image_file = 9;
inline bool DatasetConfig::has_mean_image_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DatasetConfig::set_has_mean_image_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DatasetConfig::clear_has_mean_image_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DatasetConfig::clear_mean_image_file() {
  if (mean_image_file_ != &::google::protobuf::internal::kEmptyString) {
    mean_image_file_->clear();
  }
  clear_has_mean_image_file();
}
inline const ::std::string& DatasetConfig::mean_image_file() const {
  return *mean_image_file_;
}
inline void DatasetConfig::set_mean_image_file(const ::std::string& value) {
  set_has_mean_image_file();
  if (mean_image_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_image_file_ = new ::std::string;
  }
  mean_image_file_->assign(value);
}
inline void DatasetConfig::set_mean_image_file(const char* value) {
  set_has_mean_image_file();
  if (mean_image_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_image_file_ = new ::std::string;
  }
  mean_image_file_->assign(value);
}
inline void DatasetConfig::set_mean_image_file(const char* value, size_t size) {
  set_has_mean_image_file();
  if (mean_image_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_image_file_ = new ::std::string;
  }
  mean_image_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetConfig::mutable_mean_image_file() {
  set_has_mean_image_file();
  if (mean_image_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_image_file_ = new ::std::string;
  }
  return mean_image_file_;
}
inline ::std::string* DatasetConfig::release_mean_image_file() {
  clear_has_mean_image_file();
  if (mean_image_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mean_image_file_;
    mean_image_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DatasetConfig::set_allocated_mean_image_file(::std::string* mean_image_file) {
  if (mean_image_file_ != &::google::protobuf::internal::kEmptyString) {
    delete mean_image_file_;
  }
  if (mean_image_file) {
    set_has_mean_image_file();
    mean_image_file_ = mean_image_file;
  } else {
    clear_has_mean_image_file();
    mean_image_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string std_image_file = 10;
inline bool DatasetConfig::has_std_image_file() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DatasetConfig::set_has_std_image_file() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DatasetConfig::clear_has_std_image_file() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DatasetConfig::clear_std_image_file() {
  if (std_image_file_ != &::google::protobuf::internal::kEmptyString) {
    std_image_file_->clear();
  }
  clear_has_std_image_file();
}
inline const ::std::string& DatasetConfig::std_image_file() const {
  return *std_image_file_;
}
inline void DatasetConfig::set_std_image_file(const ::std::string& value) {
  set_has_std_image_file();
  if (std_image_file_ == &::google::protobuf::internal::kEmptyString) {
    std_image_file_ = new ::std::string;
  }
  std_image_file_->assign(value);
}
inline void DatasetConfig::set_std_image_file(const char* value) {
  set_has_std_image_file();
  if (std_image_file_ == &::google::protobuf::internal::kEmptyString) {
    std_image_file_ = new ::std::string;
  }
  std_image_file_->assign(value);
}
inline void DatasetConfig::set_std_image_file(const char* value, size_t size) {
  set_has_std_image_file();
  if (std_image_file_ == &::google::protobuf::internal::kEmptyString) {
    std_image_file_ = new ::std::string;
  }
  std_image_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetConfig::mutable_std_image_file() {
  set_has_std_image_file();
  if (std_image_file_ == &::google::protobuf::internal::kEmptyString) {
    std_image_file_ = new ::std::string;
  }
  return std_image_file_;
}
inline ::std::string* DatasetConfig::release_std_image_file() {
  clear_has_std_image_file();
  if (std_image_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = std_image_file_;
    std_image_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DatasetConfig::set_allocated_std_image_file(::std::string* std_image_file) {
  if (std_image_file_ != &::google::protobuf::internal::kEmptyString) {
    delete std_image_file_;
  }
  if (std_image_file) {
    set_has_std_image_file();
    std_image_file_ = std_image_file;
  } else {
    clear_has_std_image_file();
    std_image_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 image_size = 11;
inline bool DatasetConfig::has_image_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DatasetConfig::set_has_image_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DatasetConfig::clear_has_image_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DatasetConfig::clear_image_size() {
  image_size_ = 0;
  clear_has_image_size();
}
inline ::google::protobuf::int32 DatasetConfig::image_size() const {
  return image_size_;
}
inline void DatasetConfig::set_image_size(::google::protobuf::int32 value) {
  set_has_image_size();
  image_size_ = value;
}

// optional bool normalize_images = 12;
inline bool DatasetConfig::has_normalize_images() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DatasetConfig::set_has_normalize_images() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DatasetConfig::clear_has_normalize_images() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DatasetConfig::clear_normalize_images() {
  normalize_images_ = false;
  clear_has_normalize_images();
}
inline bool DatasetConfig::normalize_images() const {
  return normalize_images_;
}
inline void DatasetConfig::set_normalize_images(bool value) {
  set_has_normalize_images();
  normalize_images_ = value;
}

// optional float pos_frac = 13 [default = 1];
inline bool DatasetConfig::has_pos_frac() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DatasetConfig::set_has_pos_frac() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DatasetConfig::clear_has_pos_frac() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DatasetConfig::clear_pos_frac() {
  pos_frac_ = 1;
  clear_has_pos_frac();
}
inline float DatasetConfig::pos_frac() const {
  return pos_frac_;
}
inline void DatasetConfig::set_pos_frac(float value) {
  set_has_pos_frac();
  pos_frac_ = value;
}

// optional bool crop = 14 [default = false];
inline bool DatasetConfig::has_crop() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DatasetConfig::set_has_crop() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DatasetConfig::clear_has_crop() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DatasetConfig::clear_crop() {
  crop_ = false;
  clear_has_crop();
}
inline bool DatasetConfig::crop() const {
  return crop_;
}
inline void DatasetConfig::set_crop(bool value) {
  set_has_crop();
  crop_ = value;
}

// optional .config.DatasetConfig.DatasetType dataset_val_type = 15;
inline bool DatasetConfig::has_dataset_val_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DatasetConfig::set_has_dataset_val_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DatasetConfig::clear_has_dataset_val_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DatasetConfig::clear_dataset_val_type() {
  dataset_val_type_ = 0;
  clear_has_dataset_val_type();
}
inline ::config::DatasetConfig_DatasetType DatasetConfig::dataset_val_type() const {
  return static_cast< ::config::DatasetConfig_DatasetType >(dataset_val_type_);
}
inline void DatasetConfig::set_dataset_val_type(::config::DatasetConfig_DatasetType value) {
  assert(::config::DatasetConfig_DatasetType_IsValid(value));
  set_has_dataset_val_type();
  dataset_val_type_ = value;
}

// optional bool use_sampling = 16;
inline bool DatasetConfig::has_use_sampling() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DatasetConfig::set_has_use_sampling() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DatasetConfig::clear_has_use_sampling() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DatasetConfig::clear_use_sampling() {
  use_sampling_ = false;
  clear_has_use_sampling();
}
inline bool DatasetConfig::use_sampling() const {
  return use_sampling_;
}
inline void DatasetConfig::set_use_sampling(bool value) {
  set_has_use_sampling();
  use_sampling_ = value;
}

// optional bool randomize_gpu = 17 [default = false];
inline bool DatasetConfig::has_randomize_gpu() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DatasetConfig::set_has_randomize_gpu() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DatasetConfig::clear_has_randomize_gpu() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DatasetConfig::clear_randomize_gpu() {
  randomize_gpu_ = false;
  clear_has_randomize_gpu();
}
inline bool DatasetConfig::randomize_gpu() const {
  return randomize_gpu_;
}
inline void DatasetConfig::set_randomize_gpu(bool value) {
  set_has_randomize_gpu();
  randomize_gpu_ = value;
}

// optional bool warp = 18 [default = false];
inline bool DatasetConfig::has_warp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DatasetConfig::set_has_warp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DatasetConfig::clear_has_warp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DatasetConfig::clear_warp() {
  warp_ = false;
  clear_has_warp();
}
inline bool DatasetConfig::warp() const {
  return warp_;
}
inline void DatasetConfig::set_warp(bool value) {
  set_has_warp();
  warp_ = value;
}

// optional bool has_no_labels = 19 [default = false];
inline bool DatasetConfig::has_has_no_labels() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DatasetConfig::set_has_has_no_labels() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DatasetConfig::clear_has_has_no_labels() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DatasetConfig::clear_has_no_labels() {
  has_no_labels_ = false;
  clear_has_has_no_labels();
}
inline bool DatasetConfig::has_no_labels() const {
  return has_no_labels_;
}
inline void DatasetConfig::set_has_no_labels(bool value) {
  set_has_has_no_labels();
  has_no_labels_ = value;
}

// optional string predicted_boxes_file = 20;
inline bool DatasetConfig::has_predicted_boxes_file() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DatasetConfig::set_has_predicted_boxes_file() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DatasetConfig::clear_has_predicted_boxes_file() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DatasetConfig::clear_predicted_boxes_file() {
  if (predicted_boxes_file_ != &::google::protobuf::internal::kEmptyString) {
    predicted_boxes_file_->clear();
  }
  clear_has_predicted_boxes_file();
}
inline const ::std::string& DatasetConfig::predicted_boxes_file() const {
  return *predicted_boxes_file_;
}
inline void DatasetConfig::set_predicted_boxes_file(const ::std::string& value) {
  set_has_predicted_boxes_file();
  if (predicted_boxes_file_ == &::google::protobuf::internal::kEmptyString) {
    predicted_boxes_file_ = new ::std::string;
  }
  predicted_boxes_file_->assign(value);
}
inline void DatasetConfig::set_predicted_boxes_file(const char* value) {
  set_has_predicted_boxes_file();
  if (predicted_boxes_file_ == &::google::protobuf::internal::kEmptyString) {
    predicted_boxes_file_ = new ::std::string;
  }
  predicted_boxes_file_->assign(value);
}
inline void DatasetConfig::set_predicted_boxes_file(const char* value, size_t size) {
  set_has_predicted_boxes_file();
  if (predicted_boxes_file_ == &::google::protobuf::internal::kEmptyString) {
    predicted_boxes_file_ = new ::std::string;
  }
  predicted_boxes_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetConfig::mutable_predicted_boxes_file() {
  set_has_predicted_boxes_file();
  if (predicted_boxes_file_ == &::google::protobuf::internal::kEmptyString) {
    predicted_boxes_file_ = new ::std::string;
  }
  return predicted_boxes_file_;
}
inline ::std::string* DatasetConfig::release_predicted_boxes_file() {
  clear_has_predicted_boxes_file();
  if (predicted_boxes_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = predicted_boxes_file_;
    predicted_boxes_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DatasetConfig::set_allocated_predicted_boxes_file(::std::string* predicted_boxes_file) {
  if (predicted_boxes_file_ != &::google::protobuf::internal::kEmptyString) {
    delete predicted_boxes_file_;
  }
  if (predicted_boxes_file) {
    set_has_predicted_boxes_file();
    predicted_boxes_file_ = predicted_boxes_file;
  } else {
    clear_has_predicted_boxes_file();
    predicted_boxes_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_pattern = 21;
inline bool DatasetConfig::has_file_pattern() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DatasetConfig::set_has_file_pattern() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DatasetConfig::clear_has_file_pattern() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DatasetConfig::clear_file_pattern() {
  if (file_pattern_ != &::google::protobuf::internal::kEmptyString) {
    file_pattern_->clear();
  }
  clear_has_file_pattern();
}
inline const ::std::string& DatasetConfig::file_pattern() const {
  return *file_pattern_;
}
inline void DatasetConfig::set_file_pattern(const ::std::string& value) {
  set_has_file_pattern();
  if (file_pattern_ == &::google::protobuf::internal::kEmptyString) {
    file_pattern_ = new ::std::string;
  }
  file_pattern_->assign(value);
}
inline void DatasetConfig::set_file_pattern(const char* value) {
  set_has_file_pattern();
  if (file_pattern_ == &::google::protobuf::internal::kEmptyString) {
    file_pattern_ = new ::std::string;
  }
  file_pattern_->assign(value);
}
inline void DatasetConfig::set_file_pattern(const char* value, size_t size) {
  set_has_file_pattern();
  if (file_pattern_ == &::google::protobuf::internal::kEmptyString) {
    file_pattern_ = new ::std::string;
  }
  file_pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetConfig::mutable_file_pattern() {
  set_has_file_pattern();
  if (file_pattern_ == &::google::protobuf::internal::kEmptyString) {
    file_pattern_ = new ::std::string;
  }
  return file_pattern_;
}
inline ::std::string* DatasetConfig::release_file_pattern() {
  clear_has_file_pattern();
  if (file_pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_pattern_;
    file_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DatasetConfig::set_allocated_file_pattern(::std::string* file_pattern) {
  if (file_pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete file_pattern_;
  }
  if (file_pattern) {
    set_has_file_pattern();
    file_pattern_ = file_pattern;
  } else {
    clear_has_file_pattern();
    file_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string dataset_name = 22;
inline int DatasetConfig::dataset_name_size() const {
  return dataset_name_.size();
}
inline void DatasetConfig::clear_dataset_name() {
  dataset_name_.Clear();
}
inline const ::std::string& DatasetConfig::dataset_name(int index) const {
  return dataset_name_.Get(index);
}
inline ::std::string* DatasetConfig::mutable_dataset_name(int index) {
  return dataset_name_.Mutable(index);
}
inline void DatasetConfig::set_dataset_name(int index, const ::std::string& value) {
  dataset_name_.Mutable(index)->assign(value);
}
inline void DatasetConfig::set_dataset_name(int index, const char* value) {
  dataset_name_.Mutable(index)->assign(value);
}
inline void DatasetConfig::set_dataset_name(int index, const char* value, size_t size) {
  dataset_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetConfig::add_dataset_name() {
  return dataset_name_.Add();
}
inline void DatasetConfig::add_dataset_name(const ::std::string& value) {
  dataset_name_.Add()->assign(value);
}
inline void DatasetConfig::add_dataset_name(const char* value) {
  dataset_name_.Add()->assign(value);
}
inline void DatasetConfig::add_dataset_name(const char* value, size_t size) {
  dataset_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DatasetConfig::dataset_name() const {
  return dataset_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DatasetConfig::mutable_dataset_name() {
  return &dataset_name_;
}

// optional bool can_translate = 23 [default = false];
inline bool DatasetConfig::has_can_translate() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DatasetConfig::set_has_can_translate() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DatasetConfig::clear_has_can_translate() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DatasetConfig::clear_can_translate() {
  can_translate_ = false;
  clear_has_can_translate();
}
inline bool DatasetConfig::can_translate() const {
  return can_translate_;
}
inline void DatasetConfig::set_can_translate(bool value) {
  set_has_can_translate();
  can_translate_ = value;
}

// optional bool can_flip = 24 [default = false];
inline bool DatasetConfig::has_can_flip() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DatasetConfig::set_has_can_flip() {
  _has_bits_[0] |= 0x00800000u;
}
inline void DatasetConfig::clear_has_can_flip() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void DatasetConfig::clear_can_flip() {
  can_flip_ = false;
  clear_has_can_flip();
}
inline bool DatasetConfig::can_flip() const {
  return can_flip_;
}
inline void DatasetConfig::set_can_flip(bool value) {
  set_has_can_flip();
  can_flip_ = value;
}

// optional int32 random_access_chunk_size = 25 [default = 1];
inline bool DatasetConfig::has_random_access_chunk_size() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DatasetConfig::set_has_random_access_chunk_size() {
  _has_bits_[0] |= 0x01000000u;
}
inline void DatasetConfig::clear_has_random_access_chunk_size() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void DatasetConfig::clear_random_access_chunk_size() {
  random_access_chunk_size_ = 1;
  clear_has_random_access_chunk_size();
}
inline ::google::protobuf::int32 DatasetConfig::random_access_chunk_size() const {
  return random_access_chunk_size_;
}
inline void DatasetConfig::set_random_access_chunk_size(::google::protobuf::int32 value) {
  set_has_random_access_chunk_size();
  random_access_chunk_size_ = value;
}

// optional int32 gpu_id = 26 [default = 0];
inline bool DatasetConfig::has_gpu_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DatasetConfig::set_has_gpu_id() {
  _has_bits_[0] |= 0x02000000u;
}
inline void DatasetConfig::clear_has_gpu_id() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void DatasetConfig::clear_gpu_id() {
  gpu_id_ = 0;
  clear_has_gpu_id();
}
inline ::google::protobuf::int32 DatasetConfig::gpu_id() const {
  return gpu_id_;
}
inline void DatasetConfig::set_gpu_id(::google::protobuf::int32 value) {
  set_has_gpu_id();
  gpu_id_ = value;
}

// optional int32 max_dataset_size = 27 [default = 0];
inline bool DatasetConfig::has_max_dataset_size() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DatasetConfig::set_has_max_dataset_size() {
  _has_bits_[0] |= 0x04000000u;
}
inline void DatasetConfig::clear_has_max_dataset_size() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void DatasetConfig::clear_max_dataset_size() {
  max_dataset_size_ = 0;
  clear_has_max_dataset_size();
}
inline ::google::protobuf::int32 DatasetConfig::max_dataset_size() const {
  return max_dataset_size_;
}
inline void DatasetConfig::set_max_dataset_size(::google::protobuf::int32 value) {
  set_has_max_dataset_size();
  max_dataset_size_ = value;
}

// optional int32 raw_image_size = 28 [default = 0];
inline bool DatasetConfig::has_raw_image_size() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void DatasetConfig::set_has_raw_image_size() {
  _has_bits_[0] |= 0x08000000u;
}
inline void DatasetConfig::clear_has_raw_image_size() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void DatasetConfig::clear_raw_image_size() {
  raw_image_size_ = 0;
  clear_has_raw_image_size();
}
inline ::google::protobuf::int32 DatasetConfig::raw_image_size() const {
  return raw_image_size_;
}
inline void DatasetConfig::set_raw_image_size(::google::protobuf::int32 value) {
  set_has_raw_image_size();
  raw_image_size_ = value;
}

// optional int32 stride = 29 [default = 1];
inline bool DatasetConfig::has_stride() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void DatasetConfig::set_has_stride() {
  _has_bits_[0] |= 0x10000000u;
}
inline void DatasetConfig::clear_has_stride() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void DatasetConfig::clear_stride() {
  stride_ = 1;
  clear_has_stride();
}
inline ::google::protobuf::int32 DatasetConfig::stride() const {
  return stride_;
}
inline void DatasetConfig::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// optional bool pixelwise_normalize = 30 [default = false];
inline bool DatasetConfig::has_pixelwise_normalize() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void DatasetConfig::set_has_pixelwise_normalize() {
  _has_bits_[0] |= 0x20000000u;
}
inline void DatasetConfig::clear_has_pixelwise_normalize() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void DatasetConfig::clear_pixelwise_normalize() {
  pixelwise_normalize_ = false;
  clear_has_pixelwise_normalize();
}
inline bool DatasetConfig::pixelwise_normalize() const {
  return pixelwise_normalize_;
}
inline void DatasetConfig::set_pixelwise_normalize(bool value) {
  set_has_pixelwise_normalize();
  pixelwise_normalize_ = value;
}

// optional float pca_noise_stddev = 31 [default = 0];
inline bool DatasetConfig::has_pca_noise_stddev() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void DatasetConfig::set_has_pca_noise_stddev() {
  _has_bits_[0] |= 0x40000000u;
}
inline void DatasetConfig::clear_has_pca_noise_stddev() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void DatasetConfig::clear_pca_noise_stddev() {
  pca_noise_stddev_ = 0;
  clear_has_pca_noise_stddev();
}
inline float DatasetConfig::pca_noise_stddev() const {
  return pca_noise_stddev_;
}
inline void DatasetConfig::set_pca_noise_stddev(float value) {
  set_has_pca_noise_stddev();
  pca_noise_stddev_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace config

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::Layer_Activation>() {
  return ::config::Layer_Activation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::Optimizer_OptimizerType>() {
  return ::config::Optimizer_OptimizerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::Optimizer_Decay>() {
  return ::config::Optimizer_Decay_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::Edge_EdgeType>() {
  return ::config::Edge_EdgeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::Edge_Initialization>() {
  return ::config::Edge_Initialization_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::DatasetConfig_DatasetType>() {
  return ::config::DatasetConfig_DatasetType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_convnet_5fconfig_2eproto__INCLUDED
